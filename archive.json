{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-20T01:44:47.160196+00:00",
  "repo": "ietf-wg-scone/scone",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "bike shed",
      "description": "",
      "color": "d4c5f9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDON1dwo86qsnWm",
      "title": "Throughput advice format",
      "url": "https://github.com/ietf-wg-scone/scone/issues/1",
      "state": "CLOSED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While we're figuring out how to agree on a throughput advice format we could initially include both options:\n\n- A TRAIN Packet always includes a payload field of size N after the SCID. \n- The third most significant bit is set to 1 when a network element updates the payload field. \n- If the bit is not set, the low 5 bits are used to signal a preset rate.",
      "createdAt": "2025-02-19T16:20:44Z",
      "updatedAt": "2025-04-08T11:32:27Z",
      "closedAt": "2025-04-08T11:32:26Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We are back to the composability argument. TRAIN is designed to pick \"the lowest of multiple assertions\". During the discussion, I heard the view that there is no need for that, because in practice there is only one bottleneck and one TRAIN rewriter. I am really not sure about that -- I can really imagine a cascade of NATs, each believing that they are the only one enforcing bandwidth. The rule that you propose implies that any \"rewriter\" must check a specific bit, and if it is set jump to the payload and analyze it. Which implies that all on path agents will need to support \"checking the payload\", in which case I am not sure I see the point of having the information in the top bits.",
          "createdAt": "2025-02-20T08:15:50Z",
          "updatedAt": "2025-02-20T08:15:50Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's fine if we eventually converge on a single format / location for the advice (I have my bias already).  \nIn order to get there it might be useful to have both options on the table so we can do some early implementations and measurements.\n\nAlso, with regards to composability. I agree that there are possible cases, but they are probably not that common. A network element that only considers the top bits could simply not send throughput advice if it sees the \"check the payload\" bit. ",
          "createdAt": "2025-02-20T10:26:28Z",
          "updatedAt": "2025-02-20T10:26:28Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on the agreed design this issue is no longer relevant. ",
          "createdAt": "2025-04-08T11:32:26Z",
          "updatedAt": "2025-04-08T11:32:26Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDON1dwo86qspaJ",
      "title": "Name",
      "url": "https://github.com/ietf-wg-scone/scone/issues/2",
      "state": "CLOSED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bike shed"
      ],
      "body": "We have a few options:\n\n1. Keep TRAIN\n2. Find something that fits TRONE\n3. Completely new name, e.g., Throughput Advice Signaling Protocol (TASP)\n\nI'd be fine with any of the above. ",
      "createdAt": "2025-02-19T16:24:24Z",
      "updatedAt": "2025-05-05T14:46:37Z",
      "closedAt": "2025-05-05T14:46:37Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could also call it SCONE.\n",
          "createdAt": "2025-04-16T16:04:53Z",
          "updatedAt": "2025-04-16T16:04:53Z"
        },
        {
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please implement the naming change in the draft.",
          "createdAt": "2025-04-23T07:00:07Z",
          "updatedAt": "2025-04-23T07:00:07Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDON1dwo86u3xiG",
      "title": "Adoption and Business implications of \"A single Rate Signal field\"",
      "url": "https://github.com/ietf-wg-scone/scone/issues/4",
      "state": "OPEN",
      "author": "atiwariphd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The payload of a TRONE packet consists of a single Rate Signal field\n\nI would like to raise an issue to make sure everyone understands the adoption and business implication of the above constraint. \n\nA single rate value does not clearly explain how this rate should be measured and how the two parties (the sender of the rate signal and recipient of the rate signal) should interpret this signal in a consistent fashion. So if two parties (a Communication Service Provider and a Content and Application Provider) want to use this signal, they will have to have offline discussions between their business and technical teams to establish a common way of interpreting this signal. \n\nThis inherently will create barriers to entry for small app startups to use TRONE because typically small startups do not have the luxury of hiring a large partnership and technology ecosystems team to interface with multiple CSPs around the world to figure out how to interpret the \"single rate signal\" coming from their network.\n\nWe need to ask ourselves, do we want IETF to design a protocol that is only usable by large companies with plenty of resources?",
      "createdAt": "2025-03-20T02:49:44Z",
      "updatedAt": "2025-03-20T10:44:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is a lot of value in simplicity. A single rate signal and guidance in the document around how to interpret the signal makes it easy to reason about. \nDifferent CSPs might measure conformance in different ways, but the associated action to detection of non-conforming traffic would likely be that policing is re-introduced for a flow, or that a lower rate is signaled. Both these actions can be detected and acted upon by the endpoints. ",
          "createdAt": "2025-03-20T10:44:23Z",
          "updatedAt": "2025-03-20T10:44:23Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDON1dwo86u5K3z",
      "title": "Client-initiated signal",
      "url": "https://github.com/ietf-wg-scone/scone/issues/5",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "1. Section 2 of the draft shows \"QUIC Sender\", ie, the server initiates the TRONE signal toward the client. This implies that TRONE signal is going to be server initiated. This will result in having the \"network element\" listens to all IP flows in the downlink direction. This is CPU intensive\n2. The authors should consider a design that is independent of SNI-based flow detection\n3. The authors should reconsider this design and allow for CLIENT initiated TRONE signaling (uplink direction) with implicit support for  flow detection\n\nAs a point of reference, section 6 of draft mishra-scone-usercase-00, added following requirement:\nSCONE (aka TRONE) signal MUST be a client-application endpoint initiated to assist the network element (UPF/5G or PGW/4G) with the implicit flow detection\nplease see https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.1.1",
      "createdAt": "2025-03-20T06:13:47Z",
      "updatedAt": "2025-05-19T23:58:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TRONE packets are sent by each endpoint individually, so there is opportunity for the client to send an early TRONE packet such that a network element that keeps some flow state can use the presence of a TRONE packet as an indication to not do further DPI and SNI parsing etc. \nThe problem in the current draft version is that endpoints need to indicate support using transport parameters before  sending TRONE packets. The authors have discussed an approach where an opportunistic TRONE \"indication\" can be appended to a QUIC initial packet. The network element can use this information as an indication that the client is willing to receive rate signals. \nAs opposed to \"regular\" TRONE packets, this indication would have to be appended to the end of a QUIC Initial packet.",
          "createdAt": "2025-03-20T06:43:56Z",
          "updatedAt": "2025-03-20T06:45:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have a lot of good discussion going on in #23, but maybe an issue is better to explain how people view the problem. So here are my thoughts:\n\nAs I understand, there are two types of flows with different characteristics:\n\n1. flows rate-limited using CC\n2. flows for which short bursts are allowed, with the assumption that the long-term bitrate is below the policy\n\nBecause SCONE signals are purely advisory that endpoints often cannot adhere to (see #29), network elements have to monitor the long-term bitrate of type 2 connections, and if they are exceeding the limit, demote them to type 1. This would be the ordinary business for any SCONE-compatible network elements with the capability to enforce bitrates.\n\nIf network elements want to demote flows without paying the cost of monitoring the long-term bitrate, they can consult the QUIC Version field of the first few packets sent by the server. As stated, there will be false positives; hence this is an optimization.\n\nThe question regarding client-driven indication is, IMO, if we want to have another knob for optimization, providing the capability to demote flows just by looking at the first packet from the client. Note we would have even more false positives than the first knob, because clients might be sending Indications to servers that do not support SCONE.\n\nWhile I\u2019m not necessarily opposed to having Indications, I am still wondering why some think it is insufficient to only have the first optimization knob (i.e., see if the server sends SCONE packets early).\n\nThe heavyweight task that the network elements cannot avoid is actually measuring the long-term flow rate and demoting the connections. Compared to that the benefit for having the 2nd knob (Indications) seems marginal if any, even though it makes things much more complex.",
          "createdAt": "2025-05-01T06:30:03Z",
          "updatedAt": "2025-05-01T06:30:03Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "Hi @kazuho \n\nThanks for your thoughts on this. Following up on the discussion, here's my perspective:\n\nFrom a network element standpoint that uses deep packet inspection (DPI) for rate limiting, the process involves identifying potential video sessions and then applying rate limits based on the subscriber's data plan (e.g., 2 Mbps, 4 Mbps). This results in traffic being passed to the radio network at the specified bit rate, and any excess traffic arriving at a faster rate is discarded.\n\nConsidering this within the SCONE working group, it seems beneficial if a client application on the user equipment (UE) initiating adaptive bitrate (ABR) video playback could signal to the rate-limiting network element: \"I can send packets at a rate you can handle, so you don't need to drop them.\" This uplink indication would provide the network element with information to consider.\n\nUpon receiving such a signal, the network element might forgo DPI and potentially wait for a corresponding signal on the downlink for the same 4-tuple (within a reasonable timeout period) before applying the allowable rate limit. While inspecting downlink traffic can be resource-intensive, minimizing this inspection could be a desirable optimization.\n\nConversely, without this client-side notification, a network element relying on DPI will likely start enforcing rate limits immediately at the beginning of a video session, as it has no initial way of knowing if the client application is SCONE-capable.\n\nFor SCONE deployment, this early signaling mechanism distinguishes SCONE flows from non-SCONE flows. It's also important to note that SCONE usage is separate from the congestion control mechanisms within the mobile packet core and the RAN, and therefore outside the scope of our SCONE discussions.\n\nThanks,\nSanjay",
          "createdAt": "2025-05-02T16:49:03Z",
          "updatedAt": "2025-05-02T16:49:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> From a network element standpoint that uses deep packet inspection (DPI) for rate limiting, the process involves identifying potential video sessions and then applying rate limits based on the subscriber's data plan (e.g., 2 Mbps, 4 Mbps). This results in traffic being passed to the radio network at the specified bit rate, and any excess traffic arriving at a faster rate is discarded.\n\nObviously, if your condition is that you do DPI, then you do DPI.  But if your goal is to ensure that video does not exceed a given limit, is DPI really necessary?\n\nMy understanding is that the main concern is high network consumption over long periods of time, something that video is uniquely \"good\" at.  Right now, you use DPI to ensure that you do not limit non-video flows.  But in a world where you have the potential for SCONE to be used on those flows that you are interested in, isn't there a different approach?\n\nAt the start of a flow, you do not limit it, but set a timer.  If that timer pops without seeing SCONE, you switch the rate limit on with a relatively small window.  However, if you see a SCONE signal before then, you switch the timer on with a looser timer.  The rate limit would be the same in both cases, but the SCONE flow would have a deeper token bucket, so would be able to perform better.  There's no DPI involved.  The cost being that video flows will potentially observe huge throughput for the path and might get overenthusiastic in their choice of quality, which can degrade the overall experience.\n\nNow, with an indication, you are in much the same situation.  A signal might cause the DPI to be skipped, but then you still have two eventual end states: one where the signal never manifests and one where you see a SCONE signal.  I can't imagine that the outcome is any different.\n\nI say that because when you say:\n\n> Upon receiving such a signal, the network element might forgo DPI and potentially wait for a corresponding signal on the downlink for the same 4-tuple (within a reasonable timeout period) before applying the allowable rate limit. \n\nThat implies that you are exposing yourself to flows opting out of DPI.  And you can't go back in time and do DPI for that flow if you do that.  So if the signal never arrives -- something that seems likely -- you have lost the opportunity to \"classify\" the flow according to your DPI-based logic.\n\nFor me, the only thing that is potentially relevant here is this transitionary period where only some clients and servers support SCONE.  There, having an indication might be useful, but I don't see the game theory of this working out.  I can't see a network that currently uses DPI for classification giving that up; so unless you want to promise that on behalf of your employer and find other network operators willing to make similar commitments, this all seems pretty speculative to me.",
          "createdAt": "2025-05-05T00:38:10Z",
          "updatedAt": "2025-05-05T00:38:10Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For me, the only thing that is potentially relevant here is this transitionary period where only some clients and servers support SCONE. There, having an indication might be useful, but I don't see the game theory of this working out. I can't see a network that currently uses DPI for classification giving that up; so unless you want to promise that on behalf of your employer and find other network operators willing to make similar commitments, this all seems pretty speculative to me.\n\nI am not in a position to make any promises or name individual companies for that matter. But what I can say is that, in several conversations with CSPs, the potential for reducing the load caused by DPI in the user plane functions is one of the most attractive aspects of SCONE-like solutions. Initially, they would not disable DPI; rather, they would introduce SCONE into their DPI signatures. Packet filters matching \"_the SCONE application_\" would have higher priority than the more complex ones targeting individual applications based on SNI and similar. \nThis approach allows a gradual shift to SCONE-like policies (longer enforcement windows) for traffic that adopts SCONE early, while retaining existing throttling policies (shorter enforcement windows) for other traffic.\n\nThis, of course, only matters if you're not using your DPI for other purposes as well. However, there aren't many use cases beyond this type of policy enforcement where DPI must run in real-time on all flows (unless you're in the business of censorship or similar). Often, DPI is used primarily for collecting statistics or business intelligence; in these scenarios, performing DPI on a statistically significant subset of flows is possibly sufficient.\n\n> At the start of a flow, you do not limit it, but set a timer. If that timer pops without seeing SCONE, you switch the rate limit on with a relatively small window. However, if you see a SCONE signal before then, you switch the timer on with a looser timer. The rate limit would be the same in both cases, but the SCONE flow would have a deeper token bucket, so would be able to perform better. There's no DPI involved. The cost being that video flows will potentially observe huge throughput for the path and might get overenthusiastic in their choice of quality, which can degrade the overall experience.\n\nI would hope that we end up with something like this. \nMy worry is that the leap from the current situation to something like this approach, without an intermediate step, will be too significant for many CSPs, since it involves rethinking policy enforcement to some extent, which is more than a technical problem. The options would then be to either keep relying on DPI for classification, which reduces the incentive to deploy SCONE, or to apply some phased approach e.g., as described above, and gradually assess the benefits.\n\nAllowing for, _optional_, early SCONE indications is a way to help adoption of the technology, and is imo a small price to pay in terms of both protocol and specification complexity.\n",
          "createdAt": "2025-05-05T18:22:15Z",
          "updatedAt": "2025-05-05T18:22:15Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Color me just as skeptical as Martin. Implementations will send SCONE packets if they expect to get an advantage. We have to first explain what that advantage is. \"Getting rid of DPI\" is an advantage for the network. Application developers are not going to care much about that -- if they want to get rid of DPI, they will simply use ECH to scramble the data in the \"initial\" packets of a QUIC connection, hiding the data that DPI could find today.\n\nAnd sure, this is an arms race. If application developers better encrypt the data, the middle boxes will probably deploy some fingerprinting technique based on size and timing of the encrypted packets. This will probably succeed in identifying flows, but it requires observing enough packets to find the pattern. If the decision can wait that long, networks could just as well apply the \"delayed decision\" strategy that Martin is describing.\n\n\n",
          "createdAt": "2025-05-06T04:43:25Z",
          "updatedAt": "2025-05-06T04:46:00Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Color me just as skeptical as Martin. Implementations will send SCONE packets if they expect to get an advantage. We have to first explain what that advantage is. \"Getting rid of DPI\" is an advantage for the network. Application developers are not going to care much about that -- if they want to get rid of DPI, they will simply use ECH to scramble the data in the \"initial\" packets of a QUIC connection, hiding the data that DPI could find today.\n\n@huitema Application developers are not the only ones needed to enable SCONE adoption. There has to be an incentive for the network as well. SCONE, especially with an early indication, is one way we realistically see a way to avoid some of this \"arms race\" you describe.\n\nYou may be skeptical but we have CSPs and those that vendor equipment to CSPs saying that this would meaningfully help with SCONE deployment. What more would it take to make you _not_ skeptical?",
          "createdAt": "2025-05-06T15:59:53Z",
          "updatedAt": "2025-05-06T16:00:11Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You may be skeptical but we have CSPs and those that vendor equipment to CSPs saying that this would meaningfully help with SCONE deployment. What more would it take to make you _not_ skeptical?\n\nI don't like to deal in cliches, but you want a \"win win\" strategy. There has to be something gained by the application, otherwise it will just not bother. Plausible gains:\n\n1) Allow application to implement some long term tuning to network capacity (by opposition to just follow short term congestion feedback). This should result in lower latency because the application could forgo \"capacity probing\" strategies that build queues, and possibly lower power consumption (don't bother firing up a hi-def codec if you know that will not work).\n\n2) Make the traffic more \"regular\" -- the natural consequence of application tuning. The shorter queues in the network improve its overall efficiency, which should be visible in measurement of latency and packet loss.\n\nNone of that actually requires \"policing per flow\" or special-casing flows that use SCONE. Networks will still need to implement forms of active queue management at the edges, and should really work to implement ECN for real time feedback. It is just that flows that actually keep within the envelope advertised by SCONE will experience many fewer congestion events, ECN/CE marks, or AQM induced latency.\n",
          "createdAt": "2025-05-06T16:26:13Z",
          "updatedAt": "2025-05-06T16:26:13Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't like to deal in cliches, but you want a \"win win\" strategy. There has to be something gained by the application, otherwise it will just not bother. \n\n@huitema as someone from an application perspective, I think you are somewhat over-complicating the win-win. There is quite a simple win-win that would happen _today_ in many networks if we had SCONE. These are networks where:\n\n1. DPI is utilized per-flow to identify our application as video (even when it's not) and aggressively police it for a variety of reasons and in a variety of situations.\n2. The policing is heavy handed and quite difficult to deal with both from an application and transport layer perspective.\n3. Deploying ECH is not viable since ultimately \"networks are going to do what networks are going to do\" and the obvious thing to do is to be even more heavy handed since the \"arms race\" is extremely slow for them.\n\nIf we could wave a magic wand and have SCONE + the indication, there are networks where they _would absolutely_:\n1. Utilize SCONE to signal their advice.\n2. Disable 100% DPI for those flows since it has a significant cost for flow setup.\n3. Disable policing as long as the aggregate behavior of an application matches the signaled advice.\n4. Free us to deploy ECH on these flows.\n\n3 In particular would also give them a competitive edge over their peers who still rely on the policing, giving an urgency for other CSPs to adopt the same practices.\n\nWe could achieve this by having SCONE + an indication and setting it on all flows. I don't know what else to say to assure you this isn't hypothetical. It's a win for applications and for the operators. Frankly the one I am least convinced by having a big \"win\" in this situation is a vendor but at the end of the day if their customers are asking for it, they will provide it.",
          "createdAt": "2025-05-06T16:39:06Z",
          "updatedAt": "2025-05-06T16:39:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I\u2019m reading correctly, the argument for client\u2011driven Indications is to give CSPs a way to lighten their DPI burden. @ihlar\u2019s comment nicely summarizes those benefits.\n\nBut aren't there risks as well?\n\nSpecifically, I have one question: what will prevent CSPs from simply mapping these new signals onto their existing DPI\u2011based video policy? Today, any flow marked as \u201cvideo\u201d typically receives a far lower throughput allowance than generic traffic\u2014even when it\u2019s bursty. If providers treat client-driven SCONE Indications as just another way to label traffic \u201cvideo,\u201d endpoints will effectively be barred from sending any non\u2011video data over SCONE.\n\nAs we discuss in #29, that outcome would sabotage browser adoption\u2014browsers can\u2019t predict in advance how a connection will be used, so they can\u2019t safely opt in to SCONE if it means risking severe throttling. In the end, the only services that could realistically benefit from deploying SCONE would be those already classified as video. For everyone else, the incentive could turn out to be to avoid SCONE entirely, since advertising it would trigger the very low\u2011throughput \u201cvideo\u201d treatment.\n\nOf course, CSPs remain free to throttle as they see fit\u2014but there\u2019s a world of difference between \u201cthey can throttle\u201d and \u201cwe\u2019re giving them a mechanism to reclassify potentially non\u2011video traffic as video just to throttle it.\u201d\n\nHow do we prevent that second scenario? What mechanism ensures CSPs can\u2019t just recycle their existing video\u2011throttling rules against SCONE\u2011enabled traffic?",
          "createdAt": "2025-05-08T03:21:01Z",
          "updatedAt": "2025-05-08T03:21:01Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You make a very good point @kazuho.\nI think the response to this is that sending early indications should be optional and that endpoints such as browsers should be recommended to not use them. Or at least there should be sufficient guidance around both the risks and benefits of using early indications. For native video applications the benefits are significant, as discussed above. \n\n",
          "createdAt": "2025-05-08T08:49:08Z",
          "updatedAt": "2025-05-08T08:49:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I wonder if we're trying to do two things with one mechanism and it might make sense to split them a bit?\n\nFor example, If we don't want people doing DPI, we can put the SNI in cleartext in a hypothetical MUFFIN packet in the same UDP packet as the ClientHello. To be clear, I am not at all sure this is a good idea, but at least there's no DPI and it aligns with my general principle of \"If I wanted the network to know something, I'd tell it explicitly.\"\n\nI'd also be fine having a packet type that says \"Put the reverse path bandwidth in this\" that we can send in the first flight if we're doing 0-RTT and with the ClientFinished if we're not.  That would prevent it ever being sent in cases it hadn't been negotiated.\n\nFor throttling, I think the implementation is fairly easy: Keep doing what you're doing until you see a SCONE packet.  My understanding is that most networks have some initial token-bucket model to ensure web pages load quickly, so they might let the first 100 packets through unthrottled even today.\n\nAs a person who writes congestion controllers and runs QUIC on servers, having the receiver and not the sender receive this signal is potentially problematic. It's fine for apps, but are we going to expose this value to browser clients so they can do ABR or communicate it to the server so it can do ABR?\n\nPaths are commonly not symmetric, so I can appreciate the benefits of sending the SCONE packet in the relevant data path, but I do really want to have this information sender-side.",
          "createdAt": "2025-05-08T13:16:18Z",
          "updatedAt": "2025-05-08T13:16:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ihlar \n> I think the response to this is that sending early indications should be optional and that endpoints such as browsers should be recommended to not use them. Or at least there should be sufficient guidance around both the risks and benefits of using early indications. For native video applications the benefits are significant, as discussed above.\n\nI\u2019m not sure client\u2011driven Indications will even help native video apps. If you\u2019re already rate\u2011limited, you\u2019ve got nothing to lose by signaling early. But if you\u2019re not rate\u2011limited today, you have every incentive to avoid SCONE\u2014being tagged \u201cvideo\u201d means worse throughput and user experience.\n\nPut another way, the real danger is that only the apps CSPs already classify as video will adopt SCONE (since their performance can\u2019t get any worse), while everyone else steers clear. CSPs could then simply continue throttling based on those Indications, just as they do with DPI today.\n\nThat outcome would be a defeat: we\u2019d have built a mechanism that helps CSPs maintain\u2014or even strengthen\u2014their rate\u2011limiting, by providing an explicit signal, precisely the opposite of what this WG is chartered to achieve.",
          "createdAt": "2025-05-08T15:44:28Z",
          "updatedAt": "2025-05-08T15:44:28Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I don't understand how any of this changes significantly with or without the indication. Without the indication, the exact same thing would happen, just later in the connection when an endpoint sends an actual SCONE packet. Indications change nothing about what information is visible to a network element, so how do they change the decision calculus? In fact, without ECH the _exact same information_ is available at the same time (the client's ability to receive SCONE packets), by parsing the CH and looking for the SCONE transport parameter. It's just relatively costly to do so but since the existing practice requires decrypting the Initial packet anyway, it's perfectly viable to do.\n\nAn endpoint cannot control what the network does or does not decide based on SCONE or an indication or (as is common today) the contents of SNI or IP addresses. It is a similar problem to ECH, where taking away information can lead to the outcome of degrading _all_ traffic.\n\nWe are falling into the trap of re-litigating the utility and benefit of SCONE in general, rather than focusing on the indication itself. Having an indication or not does not change the information available to a network element about a flow, it is a detail that changes how accessible and when it is accessible. Clients are free to utilize or not utilize SCONE as they please, and network elements are free to utilize it or not utilize it. The exact same would be true for an indication.",
          "createdAt": "2025-05-08T16:13:20Z",
          "updatedAt": "2025-05-08T16:13:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mjoras \u201cSignificance\u201d is a subjective word.\n\nLet me explain how I understand the incentives of different types of network elements, how they might use Indications, and what outcomes may result.\n\nConsider three types of network elements capable of applying different policies to flows:\n\n* A. Elements that inspect the first packet from the client and enforce different bitrates using congestion control (CC).\n* B. Elements that can observe the throughput of a small number of SCONE flows and apply CC based on long-term flow rates.\n* C. Elements that can observe the throughput of all SCONE flows and apply CC based on long-term flow rates.\n\nFor type A elements, Indications could become a new tool to identify the type of flow and apply CC accordingly. This behavior wouldn\u2019t negatively affect flows already throttled by SNI inspection. However, it would hinder SCONE adoption among applications that currently aren't throttled\u2014being (mis)classified as video flows would lead to lower throughput.\n\nFor type B elements, Indications might be beneficial during SCONE\u2019s early adoption phase. These elements can distinguish between potentially SCONE flows and definitely non-SCONE flows just by inspecting the first client packet. They could treat the small number of SCONE flows differently while continuing to apply DPI + CC-based throttling to the non-SCONE majority.\n\nBut as SCONE adoption grows and the number of SCONE flows approaches or exceeds the capacity of these network elements, what happens then? As far as I can tell, their only practical option is to revert to applying CC-based throttling to SCONE flows. That\u2019s the only viable path forward.\n\nFor such elements, it's possible they would behave similarly even without Indications. While inspecting the first packet is easier, they can still analyze later packets if needed.\n\nHowever, the key point is this: network elements that behave in this manner\u2014like type A\u2014would deter SCONE adoption at the endpoint, or cause users to disable SCONE, because using SCONE would result in degraded performance.\n\nFor type C elements, Indications are unnecessary. These elements can assume all flows are SCONE by default and only apply CC-based throttling if no SCONE packets are observed for a certain duration, or if long-term throughput exceeds a threshold.\n\nIn summary:\n* Indications are likely to be misused by type A elements, leading to reduced SCONE adoption.\n* Indications might help type B elements early on, but as SCONE scales, such elements may become harmful.\n* Indications are meaningless for type C elements.\n\nPeople may have different visions for SCONE, but in my view, the best-case scenario is:\n* most, if not all, internet traffic becomes SCONE;\n* network elements can recommend appropriate video bitrates to *any* flow, rather than relying on a static list of SNIs (win for network operators);\n* and bursts are allowed, enabling non-video data to transfer quickly\u2014regardless of whether the flow is application-specific or mixed (win for applications).\n\nFrom this perspective, misuse by type A elements is purely detrimental. Moreover, type A elements are the most commonly deployed today. If they begin applying CC-based limiting based on Indications, there would be little incentive for new applications to adopt SCONE. This, in turn, would remove any reason for future network elements to properly support SCONE, stalling its adoption altogether.\n\nType B elements are landmines best avoided, and we should refrain from providing incentives that would facilitate their development.",
          "createdAt": "2025-05-13T05:20:51Z",
          "updatedAt": "2025-05-13T05:46:37Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@kazuho \nScope of SCONE (if I understand it correctly) is for the UE to signal to the mobile network that it can \"self-regulate its bit rate\" provided the mobile network tells it, \"what the 'self regulate bit-rate' can be\". This is completely outside of the scope of how mobile networks manage congestion in the network (mobile packet core, the radio network and the access network). SCONE is meant for adaptive bit-rate applications such as video.\n\nSCONE signal, if adopted by content publishers + mobile operators, would only apply to QUIC flows, so even if SCONE adoption grows, in its current charter, excludes apps that do not use QUIC, for example, TCP/IP flows.\n\nLastly, mobile networks do not regulate non-video flows, so any non-video application does not gain any advantage (or disadvantage) for wanting to use SCONE signal. \n\n",
          "createdAt": "2025-05-18T02:32:35Z",
          "updatedAt": "2025-05-18T02:37:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@smishra1200 \n> Scope of SCONE (if I understand it correctly) is for the UE to signal to the mobile network that it can \"self-regulate its bit rate\"\n\nI\u2019m not sure. As the draft is currently written, [Section 3.5](https://ietf-wg-scone.github.io/scone/draft-thoji-scone-protocol.html#name-advisory-signal) notes that \u201cthe fact that an endpoint requests bitrate signals does not necessarily mean that it will adhere to them; in some cases, the endpoint cannot\u201d (see also issue #29).  In other words, SCONE does **not** promise self-regulation; it merely conveys rate-limit advice.\n\nMoreover, even if SCONE packets *did* reliably indicate self-regulation, an **Indication** in the client's very first packet cannot be trusted to mean the same thing: few clients have out-of-band knowledge that the server supports SCONE.\n\nHence an Indication is, at best, a weak hint, with, by looking so similar to SNI, carrying the risk of being misused as a replacement for congestion-control-based throttling via existing mechanisms.\n\n> SCONE signal \u2026 would only apply to QUIC flows \u2026\n\nThat is correct. Sorry if I have confused you by stating \u201call internet traffic becomes SCONE\u201d; of course I meant \u201call internet traffic using QUIC.\u201d With that clarification, the concerns above about reliability and potential misuse remain unchanged.",
          "createdAt": "2025-05-19T00:57:31Z",
          "updatedAt": "2025-05-19T01:05:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @kazuho. SCONE is defined as a way for the network to provide information to the host -- not the other way around. It only provide limited information about the host, i.e., that the host is capable to format and parse the SCONE packets.\n\nTake the example of a network that really want to provide a different service to a subset of the connections. It will probably determine some kind of pacing rate based on the information in the UDP header, possibly augmented by inspection of the\ninitial packet. The network element could document that rate in the SCONE packets, so the application can be parameterized accordingly.\n\nBut that DPI-and-pacing network is just an example. A home router may simply document the maximum data rate of the local connection, without any kind of DPI or per-connection state.\n\nIf SCONE is successful, yes, pretty much every QUIC connection will be using it, because they find the information provided by the network useful. That's the definition of success.",
          "createdAt": "2025-05-19T04:39:06Z",
          "updatedAt": "2025-05-19T04:39:06Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@kazuho, agree on [section 3.5](url) you point to above, my main point is,  _intent_ of SCONE is to not have the NE [capable of rate-limiting adaptive bit-rate video applications] throttle ABR video-traffic. Instead, send an advisory throughput signal to the endpoints video application. The expectation is that this change can result in  better \"end-user\" experience and reduce packet retransmission. Of course, if the endpoint chooses to not use the throughput advisory signal then SCONE wont be applied to that QUIC 4-tuple. \n\nSo, the question is, does any indication to the NE here helpful? Does the indicator tells NE that there is a willing app interested in self regulating traffic and therefore look to send throughput advisory signal on both direction of end-points on the first opportunity.\n\n",
          "createdAt": "2025-05-19T23:58:14Z",
          "updatedAt": "2025-05-19T23:58:14Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDON1dwo86u5RKN",
      "title": "Network Element initiate TRONE packet for Dynamic update of Throughput advise based on changing RAT or subscription plan",
      "url": "https://github.com/ietf-wg-scone/scone/issues/6",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 7.1 states \"A network element detects a TRONE packet by observing that a packet has a QUIC long header and the TRONE protocol version of 0xTBD.\" A network element then conditionally replaces the Rate Signal field with values of its choosing\"\n\nAbove implies that 'network element\" has to wait/rely on server to originate a TRONE packet for the NE to send advisory bit-rate towards the client.\n\nThis may not work well when we consider a use case such as the mobile user may move from one Radio Access Technology to another (4G to 5G or vice-versa) during an ongoing video session. Ideally, the NE should be in a position to send dynamically an  updated Throughput advisory bit-rate on its own without having to wait for server to originate a TRONE packet.\n\nIn another use case, there can be a need for the NE to send an updated Throughput advisory bitrate, if there is any change in consumption of subscribers' data plan.\n\nThere is also a requirement added in mishra-scone-usecase-00 that calls out:\nDynamic update - \"throughput advice\" MAY change during the ongoing flow and UPF/PGW SHOULD be able to send \"throughput advice\" to client-application-endpoint as soon as possible.\n\nPlease refer to https://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.5.1\n\n",
      "createdAt": "2025-03-20T06:26:49Z",
      "updatedAt": "2025-03-20T06:54:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, we do want the ability to signal rate changes in a timely fashion. \nThere are however, a number of ways to achieve this. \nIf we make it cheap enough to update the rate signal field, we can provide guidance to endpoints to generate TRONE packets at a relatively high frequency. One such advice would be to send a new advice for every new application layer \"burst\" such as the transmission of a set of HLS/DASH video segments. \nFurthermore, it is possible for network elements to insert TRONE packets of its own and expand UDP datagrams. Hopefully this will not be needed, but can be a last resort if the TRONE packet frequency is too low. Special care needs to be taken to not run into Path MTU issues, so guidance around not expanding datagrams to sizes larger than 1200 bytes (smallest maximum datagram payload size that needs to be supported for QUIC v1/v2)  could be needed.",
          "createdAt": "2025-03-20T06:54:52Z",
          "updatedAt": "2025-03-20T06:54:52Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDON1dwo86u5cxB",
      "title": "Client-side explicit ACK for receipt of TRONE packet",
      "url": "https://github.com/ietf-wg-scone/scone/issues/7",
      "state": "OPEN",
      "author": "smishra1200",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "7.3.  Feedback To Sender About Signals \n\nSuggest that the TRONE draft consider a use case for client to send an explicit ACK to the \"network element\" upon receiving a TRONE packet. Without an explicit ACK, a NE may not know if the client has received the latest Throughput advisory bit-rate. This may help the scenario where a client may not self regulate due to loss of TRONE packet with the most recent Throughput advisory bit-rate.\n\nAdding a requirement that support the ACK from client to the network element. \n\nI-D mishra-scone-usecase-00 listed the following requirement: \n\nClient-application endpoint SHOULD send acknowledgement receipt of throughput advisory signal from the network element using the SCONE (TRONE) signal\n\nhttps://www.ietf.org/archive/id/draft-mishra-scone-usecase-00.html#section-6-1.3.1",
      "createdAt": "2025-03-20T06:50:46Z",
      "updatedAt": "2025-04-30T21:25:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if acknowledging the receipt of a specific TRONE packet adds much value. \nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place. \nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not. ",
          "createdAt": "2025-03-20T09:37:12Z",
          "updatedAt": "2025-03-20T09:37:12Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "Hi Marcus, I'm cross referring a comment posted on my GitHub RE client ACK. Please see below:\n\nhttps://github.com/smishra1200/SCONE-Use-Case/issues/1",
          "createdAt": "2025-04-01T23:21:41Z",
          "updatedAt": "2025-04-01T23:21:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The clients use TRONE because they seek the advice. You have to assume that they will heed that advice, largely because of self interest. Nobody want application data thrown out randomly and causing terrible UI artefacts.\n\nAs @ihlar says, if the network wants to enforce something, it has to implement it using some kind of active queue management. Preferably signalling to the client using ECN/L4S. ",
          "createdAt": "2025-04-09T06:32:15Z",
          "updatedAt": "2025-04-09T06:32:15Z"
        },
        {
          "author": "smishra1200",
          "authorAssociation": "NONE",
          "body": "@ihlar \n\n> Not sure if acknowledging the receipt of a specific TRONE packet adds much value.\nEndpoints have already signaled their willingness to participate in the communication by inserting TRONE packets in the first place.\nNetwork elements who care about conformance will need to do measurements, regardless if TRONE packets are acknowledged or not.\nWhat you say is correct but what if the TRONE advisory packet is not received or that there is some time between the receipt of the TRONE signal and the client-app actually stepping down the bit-rate ladder?\n\nAnd as @rjt-ietf noted (below), the ACK offers network to not enforce any throughput limitation when the end-point is in the process of following the advice.\n\n> ...the throughput advice will be average bitrate within a time window, so I think it's necessary to let the CSPs know that the endpoint is following the advice \n\nBTW, for this [requirement](url) in the use case document, we have downshifted it to a \"MAY\" for FWIW",
          "createdAt": "2025-04-15T13:47:21Z",
          "updatedAt": "2025-04-15T13:47:21Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The TRONE model is for the network to provide advice. The design assume that the TRONE packet does not change the state of the network. For example, a network may be already programmed to apply a rate limiter to packets with certain characteristics, or to all packets. The TRONE packets will inform endpoints about those characteristics, so they can make useful decisions such as picking a video codec that remains within those envelopes. For that usage, we do not need acknowledgement: it is the responsibility of the endpoints to repeat packets if they cannot get information.",
          "createdAt": "2025-04-16T15:01:07Z",
          "updatedAt": "2025-04-16T15:01:07Z"
        },
        {
          "author": "rjt-ietf",
          "authorAssociation": "NONE",
          "body": "I'm ok with networks assuming an endpoint will follow the advice if TRONE packets are sent.\nBut I think the TRONE communication **may** change the state of a network.\nA network may have a generic limiter that looks at data at a 3-second window. But with TRONE, it should switch to a SCONE limiter that looks at the data window specified by SCONE, for example, 20 seconds.",
          "createdAt": "2025-04-16T15:08:09Z",
          "updatedAt": "2025-04-16T15:08:09Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "This doesn't seem necessary to me, unless the expectation is that packet loss is very high and the TRONE packets are relatively infrequent.",
          "createdAt": "2025-04-16T15:22:40Z",
          "updatedAt": "2025-04-16T15:22:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "My position here is that the closing of the feedback loop is something that belongs at the application layer.  We don't need this in the protocol.  As Sanjay's requirement says (eliding 2119 language and adding emphasis) \"**Client-application** endpoint [sends] acknowledgement receipt of throughput advisory signal [...]\".\n\nChanging QUIC to handle this might seem like a good idea.  It smooths the path for feedback and ensures consistent implementation.  However, this protocol operates outside of QUIC for the most part; you might equally ask why we aren't providing the feedback in HTTP/3.\n\nThe clincher for me is that it depends very much on application regarding the exact form that feedback takes.  HLS applications won't need to send any direct advice feedback, the client only needs to use the information to choose a different chunk at the next opportunity.",
          "createdAt": "2025-04-30T21:25:20Z",
          "updatedAt": "2025-04-30T21:25:20Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDON1dwo86vExP6",
      "title": "Detail interaction with congestion control",
      "url": "https://github.com/ietf-wg-scone/scone/issues/8",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "This came on repeatedly during the Bangkok IETF session. Congestion control and Trone are complementary, but we need to explain how that complementing works.",
      "createdAt": "2025-03-21T04:53:23Z",
      "updatedAt": "2025-04-16T17:15:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "Totally agreed @huitema . We tried to describe the distinction between SCONE and ECN in an [earlier draft](https://datatracker.ietf.org/doc/draft-tomar-scone-ecn/) but I am glad you are owning up to describe the complementarity of Trone and congestion control wholistically.",
          "createdAt": "2025-03-26T15:48:42Z",
          "updatedAt": "2025-03-26T15:48:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "During the 4/16/25 interim, we agreed to only merge part of PR #16, leaving aside a bunch of text:\n\n1. Speculative text about using congestion control signals to trigger TRONE packets when congestion eases: Consider then a condition in which congestion eases, either because the\ncompeting connections end or because the wireless transmission capacity\nimproves. The endpoints will notice that the rate of ECN marking rate has\nbecome low enough, and that the path is not congested anymore. However,\nthey don't know by how much they can increase their sending rate. Most\ncongestion control algorithms will proceed cautiously, allowing the\napplication to increase its sending rate step by step and verifying at each\nstep that they are not causing congestion. In these cases, a TRONE\nsignal can inform them about the changed capacity of the path and allow\nthem to increase capacity faster.\n\n2. Speculative text about using the TRONE signal to inform congestion control at the beginning of a connection: The TRONE signal can be particularly useful at the very beginning of a\nconnection. Congestion control algorithms typically start with a\nslow start process in which the application is allowed to double\nits sending rate after each RTT, until congestion is notified. This\nresults in a burst of excess transmission during the last RTT,\ncreating queues and possibly causing packet losses. Queues and\nlosses will affect not just the new connection that is testing the\ncapacity of the path, but also all established connections that\nshare the bottleneck. If the endpoints are using TRONE and learned the\nmaximum capacity of the path, they can exit the slow start process\nas soon as the maximum capacity has been tested, and avoid creating\nqueues or causing packet losses.\n\n3. Speculative text linking TRONE and \"careful resume\": The TRONE signal can also be useful if the applications remembers the\ncongestion control parameters of previous connections, and uses a\n\"careful resume\" process to quickly ramp up capacity as specified\nin  ({{?I-D.ietf-tsvwg-careful-resume}}). The endpoints could use\nTRONE to verify that the path characteristics have not changed\nsince the last connection before applying the careful resume\nprocess.\n\n4. General advice that if congestion uses the TRONE signal, it should be aware that if could be spoofed: In all cases, the endpoints should consider that the TRONE signal could\nhave been spoofed (see {{security}}). The congestion controller can use\nthe maximum capacity indicated by TRONE as a guide, but it\ncan also cautiously probe for available\ncapacity beyond the limit until receiving congestion signals.\n\nWe may want to use some of this text to specify whether and how congestion control use the TRONE signal. This is not obvious, because the general advice is that the two are independent, but it would be naive to believe that nobody would try plugging the capacity signaled by TRONE in their congestion controller. It might be better to explain the pitfalls of doing that, and perhaps signal the rare points where it makes sense.\n\nWe may also want to look at how \"easing of congestion\" could be used as a trigger for sending SCONE packets. This is somewhat experimental, because current congestion algorithms only detect easing of congestion if the application can push more data. An application working under the TRONE specified rate limit would not be able to do that. Updated congestion control algorithms might be able to detect easing of congestion by monitoring the rate of ECN marks, or the evolution of the RTT, but this is still a research area.",
          "createdAt": "2025-04-16T17:15:24Z",
          "updatedAt": "2025-04-16T17:15:24Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDON1dwo86vE006",
      "title": "Consider a way to do greasing",
      "url": "https://github.com/ietf-wg-scone/scone/issues/9",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is a bit of ambiguity in the specification of \"who uses TRONE\". The original Scone WG appears to have focused on adaptive bit rate video. If we strictly kept that focus, we have a privacy issue. Third parties could observe the presence of Trone headers, and infer that the end to end QUIC connection is engaged in video streaming.\n\nTo reduce the privacy issue, we could adopt a combined strategy, and ask more applications to support Trone, thus weakening the correlation between Trone and video.\n\nWe could also envisage greasing, with applications sending datagrams composed of a Trone packet, followed by a short header and random content. If the peer is not Trone capable, such greasing packets will be discarded because they do done decrypt correctly. But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.",
      "createdAt": "2025-03-21T05:04:11Z",
      "updatedAt": "2025-03-26T17:43:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "> But the third parties cannot check the encryption, so they will not be able to distinguish such packets from \"real\" Trone -- i.e., successful greasing.\n\nI am assuming you are referring to the network element as the \"third party\" here. If you prevent the network element from distinguishing the \"real\" Trone packets from the Greased packets, then how will the network element decide which packet to add the rate advisory to?",
          "createdAt": "2025-03-26T08:32:29Z",
          "updatedAt": "2025-03-26T08:32:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@atiwariphd the network element cannot distinguish between grease and real TRONE packet. I documented that as an attack in a separate PR #13 ",
          "createdAt": "2025-03-26T17:43:14Z",
          "updatedAt": "2025-03-26T17:43:14Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDON1dwo86vE3Wm",
      "title": "Could network elements mangle innocent packets?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/10",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is already discussed in the [TRAIN issue 32](https://github.com/martinthomson/train-protocol/issues/32). A Trone intermediary can mistake packets of some other applications for Trone packets. If it reqrite 6 bits, that will cause the packet to be eithre dropped or misinterpreted.\n\nAs explained by @ihlar during the IETF meeting in Bangkok, we need to distinguish:\n\n1. random collision: the end to end application issues some random first bytes that happen to mimic Trone. It will happen at low frequency.\n2. systematic collision: the end to end collision had negotiated some header that happens to Mimic Trone. All packets with that header will be mangled.\n\nThe proposed solution is for intermediaries to keep flow state and stop marking if too many packets of a flow match Trone. We need to develop that.\n",
      "createdAt": "2025-03-21T05:11:54Z",
      "updatedAt": "2025-04-08T09:29:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree we should document this and give some guidance on when to stop marking.\n\nThe use of two versions could help here as well. If the protocol mandates that endpoints send packets of both versions, only  observing packets of a single version could be an indication that these packets are mimicked and not real TRONE.\n\nSo, something like - stop marking if:\n\n1. After observing N packets, the ratio of TRONE to non-TRONE packets is close to 1.\n2. After observing M TRONE packets, the ratio of TRONE-1 to TRONE-2 (or vice versa) is close to 1.  ",
          "createdAt": "2025-04-08T09:29:05Z",
          "updatedAt": "2025-04-08T09:29:05Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDON1dwo86vE_RE",
      "title": "Spoofing attacks against intermediaries",
      "url": "https://github.com/ietf-wg-scone/scone/issues/11",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In issue #9 we discuss the possibility of greasing TRONE. Greasing is cool for privacy, but the same mechanisms can be used as an attack. Suppose something like:\n\n~~~\n+------------+    +----------+       /---------------\\       +-------------+\n|end point A | -- | Trone NE | ---- ( Big bad Internet) ---- | end point B |\n+------------+    +----------+       \\---------------/       +-------------+\n                                          |\n                                          |\n                                    +-------------+\n                                    | wily hacker |\n                                    +-------------+\n~~~\n\nThe hacker creates Trone packets with:\n\n* IP / UDP header: set IP source to address of B, IP destination to address of A\n* SCONE packet: pick a destination CID and a destination CID\n* 1RTT header: same destination  CID as SCONE packet\n* 1 RTT content: enough random bytes to look plausible\n\nThe attacker needs to know at least a valid address for end point A, so the packets will be routed through the target NE, but after that there are many possibilities:\n\n* an off path attacker can pick random values for the source address of \"B\" and for the CID.\n* an on path attacker can pick pairs of addresses that match existing hosts \"A\" and \"B\" and either random CID or CID copied from observed traffic.\n\nThe possible effects would be:\n\n* trick the NE into \"remembering\" lots of TRONE context, thus consuming lots of memory\n* force the NE to process a vast quantity of TRONE packets, thus consuming lots of resource\n* trick the NE into detecting a \"systematic collision\" (see issue #10) and thus disable TRONE for that flow.\n ",
      "createdAt": "2025-03-21T05:38:19Z",
      "updatedAt": "2025-04-30T20:12:49Z",
      "closedAt": "2025-04-30T20:12:49Z",
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDON1dwo86vv_gA",
      "title": "Is the \"version=range\" paradigm appropriate?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/14",
      "state": "CLOSED",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As presented at IETF 122, we define a \"version\" field that is used to choose between possible ranges.\nThis seems strange both from a cleanliness standpoint and from a greasing standpoint.\n\nWhen there are only two versions, the version field amounts to an extra bit in the range specifier - by including it directly in the range specifier (making it 0-127 rather than 0-63), we gain an unified range with a larger span (or a finer resolution, if we choose to reduce the multiplier in the exponential spacing).\n\nIf we desire to ensure that we can introduce more versions of the TRONE signal later, two versions with near-identical semantics are not enough.\n",
      "createdAt": "2025-03-26T07:03:56Z",
      "updatedAt": "2025-04-30T08:17:09Z",
      "closedAt": "2025-04-30T08:17:09Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think there could be discussions regarding how endpoints / network elements act and how the bit rates are encoded.\n\nRegarding the former, at the moment, the draft defines two versions of TRONE covering different ranges. Senders send both. Network elements modify both independently. Receivers calculate the minimum of the two. There is indeed some complexity, when the goal is to signal just one value (i.e., the bit rate).\n\nAn alternative design will be to allow network elements rewrite TRONE2 packets (carrying larger bit rates) to TRONE1 packets (carrying smaller rates).\n\nIf we adopt such a design, senders just need to send one TRONE packet (i.e., TRONE2). Receivers will no longer be required to calculate the minimum.\n\nNetwork elements would still be required to observe two versions and rewrite them as necessary (possibly to a different version), but considering that we only have 6 spare bits in the QUIC invariants before variable length fields, I think we have to either squeeze all bit rates into 6 bits or live with having multiple versions indicating different bit rates.",
          "createdAt": "2025-04-16T10:16:13Z",
          "updatedAt": "2025-04-16T10:16:13Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the idea of rewriting is an good one. The one thing we have to be careful about, in my opinion, is that not _every_ future version of TRONE can be rewritten.\n\nSo for example, suppose the initial protocol has 0xTRONE1 and 0xTRONE2 and a network element can rewrite 0xTRONE1 <->0xTRONE2. Suppose subsequently we figure out we need a 0xTRONE3 for some purpose. I think any network element that only understands 0xTRONE1/2 should not rewrite 0xTRONE3 packets, and simply ignore them.",
          "createdAt": "2025-04-16T15:57:09Z",
          "updatedAt": "2025-04-16T15:57:09Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The idea of version rewriting is in line with the general design of using 2 version numbers to get an extra bit for the range of values.",
          "createdAt": "2025-04-17T18:12:28Z",
          "updatedAt": "2025-04-17T18:12:28Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDON1dwo86v0U91",
      "title": "TRONE with other protocols - ICE in particular?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/15",
      "state": "OPEN",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As specified, the TRONE protocol only works with QUIC. And given that it can prepend data to a datagram, it is not a drop-in with anything but QUIC.\n\nThis form of signalling is interesting to other use cases. Would it be reasonable/possible/hard/impossible to carry a TRONE packet as an ICE extension?\n",
      "createdAt": "2025-03-26T14:02:31Z",
      "updatedAt": "2025-03-27T08:22:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "atiwariphd",
          "authorAssociation": "NONE",
          "body": "@alvestrand \n\n> This form of signalling is interesting to other use cases.\n\nCan you please articulate the use case?",
          "createdAt": "2025-03-26T15:43:02Z",
          "updatedAt": "2025-03-26T15:43:02Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "The classical WebRTC VC use case is one where we set up a video call (usually between the user and a datacenter), and we want to adapt the codec configuration to the available bandwidth.\nToday we do that using congestion control only.\n",
          "createdAt": "2025-03-26T16:30:28Z",
          "updatedAt": "2025-03-26T16:30:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See issue #9 about greasing. The intermediaries do not know that a TRONE packet is in fact a QUIC packet. They merely see a TRONE packet followed by a QUIC like byte, a repeat of the connection identifier bytes, and a bunch of random looking bytes. If you want to add more complexity to ICE, your ICE implementation could certainly send UDP packets that match that format. QUIC enpoints use the \"random bytes\" for verifying that the packet is legit; you could use this random bytes to carry some kind of verifier in your ICE/TRONE packets.",
          "createdAt": "2025-03-26T17:54:06Z",
          "updatedAt": "2025-03-26T17:54:06Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "ICE packets are distinguished from other packets by looking at the first byte. TRONE packets, as specified, would put a different value in the first byte. See https://datatracker.ietf.org/doc/html/rfc7983#section-7\nIt would be trivial to specify a TRONE packet as an ICE attribute, and ICE even has support for protecting only some of the attributes in an ICE packet (it uses a hash over the message + a shared secret), but it's a non-trivial job for the router to find the TRONE packet inside the ICE message.\n",
          "createdAt": "2025-03-26T21:00:02Z",
          "updatedAt": "2025-03-26T21:00:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alvestrand that's why I suggested sending two messages, the ICE message proper, and a separate \"TRONE\" message on the same 4-tuple.",
          "createdAt": "2025-03-26T23:29:28Z",
          "updatedAt": "2025-03-26T23:29:28Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification - I imagined that you were suggesting sending a single UDP packet with a TRONE message followed by the ICE message, but sending two UDP makes much more sense. Specifying a payload that would pass the TRONE inspector and be verifiable with the ICE credentials shouldn't take much more than a page.",
          "createdAt": "2025-03-27T08:22:08Z",
          "updatedAt": "2025-03-27T08:22:08Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDON1dwo86wCKw4",
      "title": "Clarify rounding behavior for bitrate-to-signal value conversion",
      "url": "https://github.com/ietf-wg-scone/scone/issues/17",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft needs clear guidance on rounding when converting between bitrates and signal values.\n\n- Should implementers round up or down when converting from bitrates to signal values?\n- What are the practical implications of each choice? (rounding down ensures staying under capacity limits; rounding up maximizes bandwidth utilization when rate adaptation algorithms rarely use full capacity)\n- Recommend specific approach with rationale, noting the logarithmic scale means adjacent steps differ by at most ~11%\n- Include example calculations demonstrating the recommended approach\n\n\n\n",
      "createdAt": "2025-03-27T15:07:00Z",
      "updatedAt": "2025-03-27T15:07:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDON1dwo86wCPkw",
      "title": "Confusion between \"No limit\" and \"TRONE not supported on path\"",
      "url": "https://github.com/ietf-wg-scone/scone/issues/18",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft currently conflates two distinct conditions in signal value 63 to mean either:\n- The network can support unlimited bandwidth (higher than max range)\n- TRONE is not supported by network elements on path\n\nThis creates ambiguity for applications interpreting signal 63 - should they assume unlimited bandwidth or cautiously rely on congestion control? We could disambiguate this by using different signal values:\n\n- 62: No limit (bandwidth exceeds maximum range)\n- 63: TRONE not supported on path\n\nOr clearly specify how applications should interpret signal 63, acknowledging its dual meaning requires caution.",
      "createdAt": "2025-03-27T15:11:45Z",
      "updatedAt": "2025-04-08T11:28:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My personal opinion is that we don't really need a distinction here. No signal and \"unlimited\" basically means that the application and CCA aren't going to get much hinting. In practice if a network wants to hint \"YUGGGEEEE\" as a limit it could set the max one in the higher range, for example.",
          "createdAt": "2025-03-27T15:12:48Z",
          "updatedAt": "2025-03-27T15:12:48Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My personal opinion is that we don't really need a distinction here. No signal and \"unlimited\" basically means that the application and CCA aren't going to get much hinting. In practice if a network wants to hint \"YUGGGEEEE\" as a limit it could set the max one in the higher range, for example.\n\nI agree, there is no need to distinguish between these. I take 63 to mean there is no limit in this range, whether that is due to an active policy or absence thereof makes no difference. ",
          "createdAt": "2025-04-08T11:28:45Z",
          "updatedAt": "2025-04-08T11:28:45Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDON1dwo86wDn_2",
      "title": "Privacy considerations when sending different TRONE protocol versions",
      "url": "https://github.com/ietf-wg-scone/scone/issues/19",
      "state": "CLOSED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion on #12 \n\nThe draft currently recommends alternating between TRONE1 and TRONE2 versions without addressing the privacy implications. We should think about this more and at least add some considerations to the text.\n\nTo ensure network elements know TRONE is supported while minimizing information disclosure, one idea would be:\n\n- Send at least one packet of each version initially even if the application only operates in one range.\n- Subsequently prioritize sending the version most relevant to current bandwidth usage\n",
      "createdAt": "2025-03-27T16:50:15Z",
      "updatedAt": "2025-04-30T09:27:10Z",
      "closedAt": "2025-04-30T09:27:09Z",
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be fine to keep alternating the versions at all times, just use two datagrams to send TRONE probes. I suppose that would be the best solution from a privacy perspective (unless I'm missing something). The additional cost of alternating should be low, and there are other potential benefits as discussed in #10 .",
          "createdAt": "2025-04-08T11:58:15Z",
          "updatedAt": "2025-04-08T11:58:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To be precise, will it be:\r\na) for the first burst send TRONE1 and for the next burst send TRONE 2, or\r\nb) for each burst send both TRONE 1 and TRONE2?\r\n\r\nI assume it'd be _b\", but trying to confirm.\r\n\r\nRegarding the overhead, I agree that it'd be negligible. The lowest bitrate being proposed is 100Kbps which is ~10pps assuming 1200 byte packets. That'd mean that, if endpoints are to receive updated TRONE signals one per every 10 seconds (see #20), the difference is sending one or two QUIC packets with TRONE headers for every 100 UDP datagrams.",
          "createdAt": "2025-04-09T04:50:22Z",
          "updatedAt": "2025-04-09T04:50:22Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes agree that it should be _b_.",
          "createdAt": "2025-04-09T05:32:05Z",
          "updatedAt": "2025-04-09T05:32:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As stated in https://github.com/ietf-wg-scone/trone/issues/14#issuecomment-2809099526, we could allow network elements rewrite TRONE2 packets (carrying higher bit rates) to TRONE1.",
          "createdAt": "2025-04-16T15:44:13Z",
          "updatedAt": "2025-04-16T15:44:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that #25 has been merged, I think we can close this issue too.",
          "createdAt": "2025-04-30T09:06:08Z",
          "updatedAt": "2025-04-30T09:06:08Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #25 ",
          "createdAt": "2025-04-30T09:27:09Z",
          "updatedAt": "2025-04-30T09:27:09Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDON1dwo86xr5d8",
      "title": "Time window for suggested bitrate",
      "url": "https://github.com/ietf-wg-scone/scone/issues/20",
      "state": "OPEN",
      "author": "rjt-ietf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue is mostly in regard to  slide 11 of https://datatracker.ietf.org/meeting/122/materials/slides-122-scone-trone-questions-01, which was discussed at IETF 122.\n\nThe current draft doesn't mention this perspective so I want to open up the discussion.\n\nIn general, I think that a fixed window length specified by SCONE is preferable as it simplifies works for network elements. But meanwhile, we need to find a window that works for all users of SCONE.\n\nDifferent video applications choose to buffer different lengths of videos during playbacks. For example, App A may buffer 10s while App B buffers 20s. A 10-second window will work for app A but not work for app B. A 20-second window will work for both.\n\nA flow that complies with a short window will also comply with a longer one.\n\nThis means we should probably specify a longer window to accommodate different applications, but not too long that exceeds the average duration of a video connection. ",
      "createdAt": "2025-04-08T22:27:05Z",
      "updatedAt": "2025-04-16T15:35:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This means we should probably specify a longer window to accommodate different applications, but not too long that exceeds the average duration of a video connection.\r\n\r\nAgreed.\r\n\r\nSince network devices cannot identify the actual application protocol being used (e.g., HLS, WebRTC, MOQ), the responsiveness to TRONE signals they can expect corresponds to that of the least responsive application protocol.\r\n\r\nAssuming that HLS would use chunks as large as 10 seconds, and assuming that each chunk would be sent at full speed, window of 20 seconds is a good ball-park figure, IMO.",
          "createdAt": "2025-04-09T04:42:48Z",
          "updatedAt": "2025-04-09T04:42:48Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "For realtime video, the interesting timeframe  is the next 20 ms - we don't buffer on the HLS timescale.\nPermitted burst size is of interest, but mainly because we don't want the L4S problem of sending a keyframe and having the last packet of the frame be marked as congestion-experienced because the whole keyframe was sent at line rate.\n\n",
          "createdAt": "2025-04-09T06:20:51Z",
          "updatedAt": "2025-04-09T06:20:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there are two separate questions:\n* time window of the signals being emitted by network elements (which would be the window that they would use for detecting abuse)\n* how frequent endpoints request / receive updates\n\nFor the first question, unless endpoints agree to expose what type of application they are, the time window has to be that of the application that takes the longest time to adopt to the SCONE signal. My guess is that that application would be HLS, and that therefore the time window should be in the order of 10 seconds.\n\nFor the second question, I think there is no need to forbid endpoints requesting SCONE signals more frequently, e.g., by sending TRONE packets.",
          "createdAt": "2025-04-09T23:47:54Z",
          "updatedAt": "2025-04-09T23:48:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "SCONE is intended for timeframes of multiple RTTs at a minimum, so I would expect 30 seconds or a minute to be a reasonable timeframe.",
          "createdAt": "2025-04-16T15:26:16Z",
          "updatedAt": "2025-04-16T15:26:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion at Interim 3: we need to pick a value now for the doc to be adopted. 20 seconds seems to be a good starting point. Keeping this issue open to make sure we don't lose the finer points here.",
          "createdAt": "2025-04-16T15:35:22Z",
          "updatedAt": "2025-04-16T15:35:22Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDON1dwo86yoU-z",
      "title": "Network inserted TRONE packets",
      "url": "https://github.com/ietf-wg-scone/scone/issues/21",
      "state": "OPEN",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The topic of whether network elements should be able to generate TRONE packets and insert them into expanded datagrams was discussed at IETF 122. Also discussed in #6.\nIdeally this should not be needed, given that there is proper guidance on when to send TRONE packets and making sure that updating the rate limit field of the TRONE packets is sufficiently cheap. The risk of expanding datagrams in the network is that it can result in path MTU issues with lost packets as a consequence. \n\nThere are a few paths we can take on this topic:\n\n1. Say nothing about it.\n2. Mention the possibility and give guidance on potential MTU issues that can arise. \n3. Explicitly forbid network inserted TRONE packets and design protocol mechanisms to enforce it.",
      "createdAt": "2025-04-15T15:59:14Z",
      "updatedAt": "2025-04-16T15:53:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I believe we should have normative text advising against doing this and why, but I doubt it's worth building a mechanism to enforce that unless it's quite simple.",
          "createdAt": "2025-04-16T15:16:54Z",
          "updatedAt": "2025-04-16T15:16:54Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I suspect it would be easy for the encrypted envelope to carry such protection of the TRONE info ... and an on-path observer would never know if the endpoint did this, or not. (However, realising the mechanism could be done later -  there may be pain in making an efficient implementation).",
          "createdAt": "2025-04-16T15:53:06Z",
          "updatedAt": "2025-04-16T15:53:06Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDON1dwo86y0OE3",
      "title": "How frequently should endpoints send TRONE packets?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/24",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This has been discussed extensively both privately, at IETF 122, and in the latest interim. We should give guidance to endpoints on how often and under what circumstances they should send TRONE packets to give an opportunity to generate new advice.",
      "createdAt": "2025-04-16T15:38:18Z",
      "updatedAt": "2025-04-22T04:14:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I were to propose an answer, I think the frequency should reflect how fast the application can adopt.\n\nTo give an example, in the case of HLS, it'd make sense to obtain one TRONE signal for each chunk but no more, because clients can switch between different bandwidths only once per chunk.\n\nIn case of applications that can adopt more rapidly, I think there is no need to constrain them from asking for an update every RTT.\n\nThe remaining question would be if sending one TRONE packet is sufficient for obtaining one signal, considering packet loss. I think the strategy can be different between the applications; some can send two packets, others can send one but use an ACK to see if the datagram that has the TRONE packet attached reached the peer. Absent ACKs, such endpoints can resend a TRONE packet.",
          "createdAt": "2025-04-22T03:54:40Z",
          "updatedAt": "2025-04-22T03:54:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Not only how fast they *can* adapt, but how fast the application might need to learn about changes.  Streaming applications might be OK with several chunks of lag if their buffers are deep enough to absorb a network fluctuation.  Per-chunk might be faster than an HLS app needs, which provides it with a degree of redundancy.\n\nApps will know when marked packets are lost -- in exactly the same way that ECN markings are accounted for in QUIC -- so they can account for that in their sending, so I don't think we need anything special, other than a note about that.",
          "createdAt": "2025-04-22T04:14:15Z",
          "updatedAt": "2025-04-22T04:14:15Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDON1dwo86zZ_iG",
      "title": "Multipath",
      "url": "https://github.com/ietf-wg-scone/scone/issues/26",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The multipath extension allows sending data on multiple paths, including multiple paths bound to the same 4 tuple. I think that a QUIC application could split its traffic along multiple paths, all identified by different connection IDs. Applications could request some of these paths to announce Trone support, other not, and maybe others still to advertise the Non-Queue-Building type.\n\nDo we fill the need to say anything about that?",
      "createdAt": "2025-04-22T05:40:54Z",
      "updatedAt": "2025-05-01T01:34:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Not that much.  We can point out that this is information that applies to a single path, not the entire connection.",
          "createdAt": "2025-04-22T07:19:55Z",
          "updatedAt": "2025-04-22T07:19:55Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe. Mostly, I am worried that network elements will combine Trone signalling and per-flow enforcement. This begs the question: what is the unit of enforcement? Four tuple? Four tuple plus CID? Address pair? Network subscription? ",
          "createdAt": "2025-04-22T18:06:02Z",
          "updatedAt": "2025-04-22T18:06:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "The unit of enforcement is unclear.  All that the network is saying is that **at some scope that includes this flow** (and it might only be this flow, but probably not) there is a policy in place to limit throughput.  It's pretty useless, except when you only have one flow that is consuming most of that limit.  The reason it works is that there is often just one active flow from a home or mobile subscription.",
          "createdAt": "2025-04-23T01:42:53Z",
          "updatedAt": "2025-04-23T01:42:53Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Unit of enforcement seems like a different issue; my impression from initial discussions was that the incremental improvement desired was to handle the situation of one dominant flow and one policer that enforced per \"customer\" (typically 6G handset or cable subscriber), and that choosing how to guide the end system to distribute the available bandwidth between multiple flows was left \"for further study\".\n",
          "createdAt": "2025-04-23T09:54:56Z",
          "updatedAt": "2025-04-23T09:54:56Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDON1dwo86zaAay",
      "title": "CID rotation and Trone",
      "url": "https://github.com/ietf-wg-scone/scone/issues/27",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "QUIC stacks will commonly \"rotate\" the connection identifiers used on a given path. Assume a connection obtained Trone information with the old connection ID. Is it still valid with the new one?",
      "createdAt": "2025-04-22T05:43:10Z",
      "updatedAt": "2025-04-23T01:44:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "If the endpoint that received the signal considers the path to be the same, then it still applies.  Worth noting, but not particularly difficult to reason about.",
          "createdAt": "2025-04-22T07:21:04Z",
          "updatedAt": "2025-04-22T07:21:04Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's again really a question about expectation and enforcement. Per 4-tuple, or per combination of 4-tuple and CID? What about DS marks? ",
          "createdAt": "2025-04-22T18:08:24Z",
          "updatedAt": "2025-04-22T18:08:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I wouldn't expect different DS markings to be applied to the same flow, but it's worth a note.  Maybe one that says \"if you use multiple DSCP markings, the throughput advice you receive from packets with one marking might not apply if packets are marked differently\".",
          "createdAt": "2025-04-23T01:44:54Z",
          "updatedAt": "2025-04-23T01:44:54Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDON1dwo860w1A_",
      "title": "How hard can network elements throttle connections that seemingly abuse SCONE?",
      "url": "https://github.com/ietf-wg-scone/scone/issues/29",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some of the interesting comments last meeting I've heard are:\n* Network elements can track usage per user and punish users or connections of such users that seemingly abuse SCONE, more so than users / connections that do not use SCONE at all.\n* Web browsers might expose SCONE rate signals to JavaScript so that JavaScript can make the decision regarding what to fetch next.\n\nI am concerned if we can allow both at the same time. I doubt that, if web browsers are going to expose SCONE rate signals to JavaScript, then there'd be a non-negligible probability of misuse (either intentional or accidental), and that we'd not want to punish web browsers for such mistakes.",
      "createdAt": "2025-04-30T22:35:36Z",
      "updatedAt": "2025-05-05T14:40:12Z",
      "closedAt": "2025-05-05T14:40:12Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, my preference would be to acknowledge that such misuse can happen ~~by accident~~, and RECOMMEND network elements just fall back to CC-based throttling as if the flow was not using SCONE at all.",
          "createdAt": "2025-04-30T22:42:53Z",
          "updatedAt": "2025-04-30T22:48:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, there is no way in which we can guarantee that an application will treat the *advice* as a limit.  Not only because they don't know about it, even if the stack they use has the necessary hooks.  There's no way to guarantee compliance other than via enforcement.  It's almost nonsensical that we're contemplating writing that down, but if there is any doubt, and some words might lay that to rest, sure.",
          "createdAt": "2025-04-30T22:54:04Z",
          "updatedAt": "2025-04-30T22:54:04Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point I was trying to make in the meeting was that there is no clear way to define what abuse of a SCONE signal means because there are different reasons for sending throughput advice and each operator will ultimately define its own enforcement policies.\n\nThe video throttling case is the one where we might see operators turning off policers while monitoring bitrates over some period; detecting non-conformance here should likely just result in fallback to the original throttling policy. Networks should expect to see this happen and I wouldn't necessarily call it abuse or misuse. That short flows might avoid getting throttled in this case is a feature imo.\n\nFor enforcement of subscriber-level data rate caps I don't think operators will turn off policers at all. SCONE advice could still be very useful in those cases, but there is no room for any kind abuse.",
          "createdAt": "2025-05-01T00:16:27Z",
          "updatedAt": "2025-05-01T00:30:40Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> there is no way in which we can guarantee that an application will treat the _advice_ as a limit\n\n+1\nThis is the most important point, as long as this is clear enough I don't think we should spend much time on discussing potential abuses and mitigations. \n",
          "createdAt": "2025-05-01T00:20:54Z",
          "updatedAt": "2025-05-01T00:21:03Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For enforcement of subscriber-level data rate caps I don't think operators will turn of policers at all. SCONE advice could still be very useful in those cases, but there is no room for any kind abuse.\n\nThey already do. My ISP does throttle the uplink connection to 20Mbps, even if the hardware would allow 50. That is prevalent enough that BBRv1 had special code to recognize these throttlers and avoid tripping them.\n\n",
          "createdAt": "2025-05-01T00:27:13Z",
          "updatedAt": "2025-05-01T00:27:13Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > For enforcement of subscriber-level data rate caps I don't think operators will turn of policers at all. SCONE advice could still be very useful in those cases, but there is no room for any kind abuse.\n> \n> They already do. My ISP does throttle the uplink connection to 20Mbps, even if the hardware would allow 50. That is prevalent enough that BBRv1 had special code to recognize these throttlers and avoid tripping them.\n\nThat's what I meant: they use policers now, and even with SCONE in place, I think they'll continue to enforce bitrates using policers.",
          "createdAt": "2025-05-01T00:32:49Z",
          "updatedAt": "2025-05-01T00:32:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you folks, I think we are more or less on the same page?\n\n>> there is no way in which we can guarantee that an application will treat the advice as a limit\n>\n> +1\n> This is the most important point, as long as this is clear enough I don't think we should spend much time on discussing potential abuses and mitigations.\n\n+1 that this is the most important point. But I continue to think that we should be more clear what it means to network operators; i.e., that if you handle flows that exchange SCONE signals but do not adhere to them differently than non-SCONE flows, that might lead to unexpected behaviors.\n\nPlease see #30.",
          "createdAt": "2025-05-01T01:22:58Z",
          "updatedAt": "2025-05-01T01:22:58Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDON1dwo862PkrX",
      "title": "Scope is restricted to 'rate limiting' networks only",
      "url": "https://github.com/ietf-wg-scone/scone/issues/32",
      "state": "OPEN",
      "author": "Kevsy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "draft-00 does not include the use of SCONE by networks that do not apply rate limit policies. For example, a cellular network that provides throughput advice based on its view of network congestion and channel conditions.  I've drafted PR which adds that as a use of SCONE, and hence changes 'rate limit signal' to throughput advice' throughout:  #31",
      "createdAt": "2025-05-12T16:38:30Z",
      "updatedAt": "2025-05-15T09:00:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aside from a few tweaks (I don't think we need to update the abstract or expand too much on why a network might want to send the advice) I'm OK with making changes along these lines.  The details matter and the change is fairly far-reaching, but it's not as large a change as it seems at first glance.",
          "createdAt": "2025-05-13T04:29:07Z",
          "updatedAt": "2025-05-13T04:29:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Belay that.  On a second more thorough pass, the suggestion that this provide information about congestion is something that should be taken to the list.  Thus far, my understanding is that we agreed (several times) that there needed to be a bright dividing line between congestion signals (like ECN) and throughput advice (SCONE).  This change seems to be aimed at erasing that line.",
          "createdAt": "2025-05-13T04:44:02Z",
          "updatedAt": "2025-05-13T04:44:02Z"
        },
        {
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "body": "Thanks @martinthomson and @huitema for the review and suggestions: limiting the PR to (1) changing 'rate limit signals' to 'throughput advice signals', and (2) including your amended text that allows cases beyond conveying rate limiting policy, is fine by me. \n\nI've applied the suggested commits accordingly to make that clearer, reverting the contentious parts.",
          "createdAt": "2025-05-13T10:53:23Z",
          "updatedAt": "2025-05-13T10:53:23Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "It would seem to me that a perfectly legitimate use of SCONE is to signal that \"you are connected via a 10 Mbit/sec Ethernet-over-copper connection, no matter what else happens, your throughput won't get higher than 10 Mbit/sec\".\n\nCongestion (the normal kind) changes too fast to be worth signalling.",
          "createdAt": "2025-05-15T08:44:41Z",
          "updatedAt": "2025-05-15T08:44:41Z"
        },
        {
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "body": "(answering from a cellular perspective)\n\n> It would seem to me that a perfectly legitimate use of SCONE is to signal that \"you are connected via a 10 Mbit/sec Ethernet-over-copper connection, no matter what else happens, your throughput won't get higher than 10 Mbit/sec\".\n\nYeah, I was also thinking indoor cellular (constrained 800Mhz) and cell edge, i.e. conditions unlikely to change for the duration of a video session. \n\n> Congestion (the normal kind) changes too fast to be worth signaling.\n\n+1, at least for now. Radio channel conditions are signaled constantly to the radio access network, but they are ephemeral and not shared to the core in real time. So 'rapidly changing urban environment' signal strength is not worth attempting to convey at this stage, but as mentioned above, there could be a way to determine when a signal strength (and hence throughput constraints) are likely to last for the session.   ",
          "createdAt": "2025-05-15T09:00:30Z",
          "updatedAt": "2025-05-15T09:00:30Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDON1dwo86MqU5p",
      "title": "Transparent Rate Optimization for Network Endpoints (TRONE)",
      "url": "https://github.com/ietf-wg-scone/scone/pull/3",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An attempt at TRONE.\r\nWe can bikeshed the name in #2.\r\n\r\nThe PR uses TRAIN as a baseline so that it's easier to review the changes from TRAIN.\r\nNote that this version changes the rate signal field to a field with explicit values, located after the CIDs.\r\nIf we're very unsure about the design tradeoffs we could consider doing both the TRAIN and TRONE ways as discussed in #1.\r\n\r\nThere's also a discussion on how network elements are capable of crafting TRONE packets. ",
      "createdAt": "2025-02-26T15:03:17Z",
      "updatedAt": "2025-03-05T13:18:41Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "b568f3314171b26d5bc38891e21c4f5f714a4c55",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "advice-format",
      "headRefOid": "946f94dac013f33e4c29520a5bdcb13f877e212c",
      "closedAt": "2025-03-03T17:42:04Z",
      "mergedAt": "2025-03-03T17:42:04Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "681b12c446391332da002b4b3cf33a0d51ab3f64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86d7v0C",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T04:25:32Z",
          "updatedAt": "2025-02-28T04:25:33Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Even if I thought that this was necessary, this is probably not the right logic to use here.  You are going to independently reduce the rate and window size.  If you don't reduce one, but you reduce the other, that is sometimes going to reduce the actual send rate below your target.  That's another reason I don't like this design.",
              "createdAt": "2025-02-28T04:25:33Z",
              "updatedAt": "2025-02-28T04:25:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86d9h0k",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T09:02:21Z",
          "updatedAt": "2025-02-28T09:02:21Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Yeah, composability makes this solution a bit messy. I've been a bit back and forth on this.  My original thinking was to only check the rate and update the window unconditionally:\r\n`if packet_rate == 0 or target_rate < packet_rate:`\r\n`    write_uint32(packet[offset : offset + 4], target_rate)`\r\n`    write_uint32(packet[offset + 4 : offset + 8], target_aw)`\r\n\r\n    \r\nThat could lead to the sending of bursts that are not tolerated by the element further upstream. \r\nIt might be the least messy thing to do with this design though. (And I still think the case with chained elements who wish to signal rates is a rather exceptional one).",
              "createdAt": "2025-02-28T09:02:21Z",
              "updatedAt": "2025-02-28T13:10:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eFfDm",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T04:40:27Z",
          "updatedAt": "2025-03-01T04:40:27Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "Thank for getting together baking this draft among authors, thanks for Martin to enage this discussion, I am wondering\r\nIs there possible to leave this as one open issue or split it from PR#3 and move to new PR. \r\nI hope we can have one posted version before submission deadline, let us know what we can do to help move the way forward.",
              "createdAt": "2025-03-01T04:40:27Z",
              "updatedAt": "2025-03-01T04:40:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eF4Fl",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-01T07:53:46Z",
          "updatedAt": "2025-03-01T07:53:47Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "The latest commit contains an update in response to Martin's comment, fixing the logic so that average window is not updated separately from updating the rate limit. Which is probably the right thing to do, given this design. \r\n\r\nThere is a larger issue around the structure and placement of the rate signal, something the WG needs to resolve. I would hope that the merged document can contain the latest commit and then we have the broader discussion as an open issue, see #1 for instance. ",
              "createdAt": "2025-03-01T07:53:46Z",
              "updatedAt": "2025-03-01T07:53:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86eOFsQ",
          "commit": {
            "abbreviatedOid": "2b0ef2f"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T15:35:01Z",
          "updatedAt": "2025-03-03T15:35:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86enOJN",
          "commit": {
            "abbreviatedOid": "bbf0242"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-05T13:18:41Z",
          "updatedAt": "2025-03-05T13:18:41Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "To be clear, I did not approve this document.",
              "createdAt": "2025-03-05T13:18:41Z",
              "updatedAt": "2025-03-05T13:18:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDON1dwo86P8JWx",
      "title": "Initial attempt at adding version-dependent logarithmic rates",
      "url": "https://github.com/ietf-wg-scone/scone/pull/12",
      "state": "MERGED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First pass, expecting there will be further changes needed. There seemed to be general consensus around this approach, which we believe we need to take before an adoption call.",
      "createdAt": "2025-03-24T22:03:34Z",
      "updatedAt": "2025-04-09T05:30:13Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "5764ba5c4c979069d5c841889845133a61fae8c7",
      "closedAt": "2025-04-09T05:30:13Z",
      "mergedAt": "2025-04-09T05:30:13Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "a4f79332ca9e716f7c255932d800191385ef33f4"
      },
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Took all the suggestions and punted some things to issues. Are we okay with this now?",
          "createdAt": "2025-03-27T16:51:01Z",
          "updatedAt": "2025-03-27T16:51:01Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Note the question in #14 - not an objection to merging this PR, but a heads-up that we may want to revisit this.\r\n",
          "createdAt": "2025-03-28T04:28:21Z",
          "updatedAt": "2025-03-28T04:28:21Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema @kazuho @martinthomson any further thoughts or are we okay to merge this and iterate?",
          "createdAt": "2025-04-03T15:35:36Z",
          "updatedAt": "2025-04-03T15:35:36Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Who actually has merge approval perms? @britram could I get it provisionally just to h it the button? \ud83d\ude42 ",
          "createdAt": "2025-04-07T20:12:52Z",
          "updatedAt": "2025-04-07T20:12:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86ho3fT",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR. Looks good overall.",
          "createdAt": "2025-03-24T22:45:22Z",
          "updatedAt": "2025-03-24T23:06:41Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n| 10 | 316 Kbps | 31.6 Mbps |\r\n```",
              "createdAt": "2025-03-24T22:45:22Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 75,
              "body": "I think we do not have these in the proposed encoding? (and IMO we probably do not need them)",
              "createdAt": "2025-03-24T22:46:27Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 89,
              "body": "Do we need this change? Not that it is incorrect, but seems a bit verbose, as the Rate Signal field is defined to be six bits.",
              "createdAt": "2025-03-24T22:48:01Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n```\r\nAs we read `version` from the packet later (see `packet[1..5]`), maybe it makes sense to delay the invocation of `convert_rate_to_signal` after that. Something like below.",
              "createdAt": "2025-03-24T22:51:30Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\npacket_version = packet[1..5]\r\nif is_long and (packet_version == TRONE1_VERSION or packet_version == TRONE2_VERSION):\r\n  target_rate_value = convert_rate_to_signal(target_rate, packet_version)\r\n```",
              "createdAt": "2025-03-24T22:54:25Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nshould signal the minimum value (0) for rates below the range and preserve the\r\noriginal value for rates above the range.\r\n```\r\nWhen there are multiple network elements, the Rate Signal field might convey a value other than 63.",
              "createdAt": "2025-03-24T23:02:53Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n```",
              "createdAt": "2025-03-24T23:03:14Z",
              "updatedAt": "2025-03-24T23:06:41Z"
            },
            {
              "originalPosition": 43,
              "body": "Do we want to state that values 0 to 62 represents the ceiling values?",
              "createdAt": "2025-03-24T23:05:53Z",
              "updatedAt": "2025-03-24T23:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpc5V",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:58:13Z",
          "updatedAt": "2025-03-25T00:58:13Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "You're right I got my wires crossed from my notes.",
              "createdAt": "2025-03-25T00:58:13Z",
              "updatedAt": "2025-03-25T00:58:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hpT6C",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T00:29:04Z",
          "updatedAt": "2025-03-25T01:21:17Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I would not do it this way.  Instead, I would set the target rate value for each version as follows:\r\n\r\n```python\r\nversions = [TRONE_VERSION1, TRONE_VERSION2]\r\ntarget = [63, 63]\r\nfor i in 1..len(versions):\r\n    target[i] = convert_rate(target_rate, versions[i])\r\n\r\n# then when a packet arrives\r\nif packet[0] & 0x80 != 0x80:\r\n    skip\r\ni = find(versions, packet[1..5])\r\nif i is not None and packet[0] & 0x3f > target[i]:\r\n    packet[0] = packet[0] & 0xc0 | target[i]",
              "createdAt": "2025-03-25T00:29:04Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n* Support for both very low bitrates (down to 100 Kbps) and very high bitrates\r\n  (up to 12.5 Gbps)\r\n* Graceful handling of network elements that might only recognize one version\r\n  or some subset of future versions.\r\n```\r\n\r\nThis is unordered.",
              "createdAt": "2025-03-25T00:29:47Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n* When sending TRONE packets, endpoints SHOULD alternate between versions\r\n```\r\nUnordered",
              "createdAt": "2025-03-25T00:30:41Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n* Network elements SHOULD apply appropriate rate signals to all packets that\r\n   include a TRONE version they support.\r\n```",
              "createdAt": "2025-03-25T00:31:45Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            },
            {
              "originalPosition": 170,
              "body": "We need to talk about rounding.\r\n\r\nIn practice, if the bitrate formula is $r=b * 10^{\\frac{n}{20}}$, the inverse is $n=\\left\\lceil 20 * \\log_{10}(\\frac{r}{b})\\right\\rceil$  or $n=\\left\\lfloor 20 * \\log_{10}(\\frac{r}{b})\\right\\rfloor$ but we should offer guidance on which to choose.",
              "createdAt": "2025-03-25T00:36:56Z",
              "updatedAt": "2025-03-25T01:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqTg8",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:24:09Z",
          "updatedAt": "2025-03-25T03:25:23Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "We should talk about the privacy trade-offs with respect to sending each.  I think that it is reasonable to send both unconditionally, but it might be better to only send these when the estimated bandwidth availability enters the range covered by each.\r\n\r\nAn application that is currently operating in the TRONE1 range could decide that it only needs to send TRONE1 packets.  That limits the number of markings that are needed and does not reveal anything extra.  The challenge being in ensuring that the network element is aware that TRONE markings are available.  For that, I would recommend always sending one packet at least once, even when the active usage is well outside of the protocol-defined ranges.\r\n\r\n\r\nHowever, an application that MIGHT operate in just the TRONE2 range reveals information that the network does not otherwise obtain if it sends the TRONE2 signal.",
              "createdAt": "2025-03-25T03:24:09Z",
              "updatedAt": "2025-03-25T03:25:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hqVP1",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T03:28:07Z",
          "updatedAt": "2025-03-25T03:28:07Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Or more clever:\r\n\r\n```python\r\ni = find(versions, packet[1..5]) if packet[0] & 0x80 == 0x80 else None\r\nif i is not None and ...\r\n```",
              "createdAt": "2025-03-25T03:28:07Z",
              "updatedAt": "2025-03-25T03:28:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrFXa",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:31:29Z",
          "updatedAt": "2025-03-25T05:31:30Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Agreed. Should I leave the text here while we work through this nuance or do you think there's something better to put in its place for now?",
              "createdAt": "2025-03-25T05:31:30Z",
              "updatedAt": "2025-03-25T05:31:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86hrGof",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T05:34:29Z",
          "updatedAt": "2025-03-25T05:34:29Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "An issue for followup is fine.",
              "createdAt": "2025-03-25T05:34:29Z",
              "updatedAt": "2025-03-25T05:34:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86htdY0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-25T09:38:15Z",
          "updatedAt": "2025-03-25T09:38:15Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "In the current state, I do not think we need to talk about rounding.\r\n\r\nWe state that the code points represent the ceiling. That means code points 0, 20, 40, 60 represent `<= 100Kbps`, `<= 1Mbps`, `<=10Mbps`, `<=100Mbps`, as they are divisible. OTOH, other values are indivisible. For example, 10<sup>1/20</sup> is 112201.84..., meaning that code point 1 represents bit rate up to 112,201bps.\r\n\r\nMaybe all we need to provide is these examples.\r\n\r\nOf course, we could go the other way and state that the 3 (or 4) most significant digits of the log function represents the bit rate...",
              "createdAt": "2025-03-25T09:38:15Z",
              "updatedAt": "2025-03-25T09:38:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2MB3",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think this is fine, except for the confusion between \"no TRONE on this path\" and \"no limit\".",
          "createdAt": "2025-03-25T22:21:17Z",
          "updatedAt": "2025-03-25T22:27:26Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think saying \"63 = No limit\" conflates two separate notions:\r\n\r\n* the TRONE protocol is not supported by network elements on the path (definition of 0x3F above)\r\n* the limit is higher that either 126Mbps or 12.6 Gbps.\r\n\r\nWe could remove that issue by defining the last lines of the table as:\r\n\r\n| 60 | 100 Mbps | 10 Gbps |\r\n| 62 | No limit | No limit |\r\n| 63 |  TRONE not supported on path |  TRONE not supported on path |\r\n\r\n\r\n",
              "createdAt": "2025-03-25T22:21:17Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 122,
              "body": "Would be \"up to 10Gbps\" if we use only 62 actual ranges.",
              "createdAt": "2025-03-25T22:22:38Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            },
            {
              "originalPosition": 170,
              "body": "I think it is fine to base the rounding on the table. I think we should say \"pick the highest rate signal that correspond to a value lower or equal to the rate\", but it might be a local decision.",
              "createdAt": "2025-03-25T22:25:20Z",
              "updatedAt": "2025-03-25T22:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h2_U7",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T00:54:09Z",
          "updatedAt": "2025-03-26T00:54:10Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "We should offer advice to network operators on the consequences of different choices.  Rounding down has the effect of guaranteeing that the used capacity is lower than the target.  However, given that applications that employ rate adaptation will rarely be able to completely use the given bandwidth, it might be better to pick a higher number.  Especially given that any excess is never more than about 11% higher than the previous step.",
              "createdAt": "2025-03-26T00:54:10Z",
              "updatedAt": "2025-03-26T00:54:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Khj",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:16:12Z",
          "updatedAt": "2025-03-26T04:16:12Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I'm not convinced that we need that feature.  What would  you do with that information?",
              "createdAt": "2025-03-26T04:16:12Z",
              "updatedAt": "2025-03-26T04:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4UB0",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T04:47:48Z",
          "updatedAt": "2025-03-26T04:47:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think there is a difference between \"more than 10Gbps\" and \"don't know\". In one case, the app has the go ahead to use a vast amount of bandwidth. In the other, the app has to proceed cautiously and rely on congestion control for a bandwidth estimate.",
              "createdAt": "2025-03-26T04:47:48Z",
              "updatedAt": "2025-03-26T04:48:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Ymh",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:04:16Z",
          "updatedAt": "2025-03-26T05:04:16Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "`10M*10^{62/20}` = 12.589G; `10M*10^{61/20}` = 11.220G.  We only get 10G if we decide to use 61 ranges.",
              "createdAt": "2025-03-26T05:04:16Z",
              "updatedAt": "2025-03-26T05:04:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4Zl7",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:07:16Z",
          "updatedAt": "2025-03-26T05:07:16Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I can't conceive of a scenario where an app would see an \"uncapped\" signal and decide that it can switch to sending at line rate.  You are taking the word of one path element and extrapolating to the entire path.\r\n\r\nLet's say that you get a 1Mbps signal.  You are currently at ~30kbps.  It might be reasonable to skip a few steps in your capacity probing to get closer to 1Mbps.  But that might be based on an assumption about the relative availability of bandwidth in modern networks and maybe past experience with the same network; I doubt you would make the same guess at 1Tbps (if that were a possible signal, that is).\r\n\r\nI conclude that while the congestion controller might be nudged a little, senders still need to have one and use that to probe the actual path availability.  The network still has queues and other users.  Expressions of policy limitations don't necessary entail guarantees, even at the node that is making that assertion.",
              "createdAt": "2025-03-26T05:07:16Z",
              "updatedAt": "2025-03-26T05:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4m8S",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:51:58Z",
          "updatedAt": "2025-03-26T05:51:58Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Sorry, I didn't do the math. But yes, that's the crux of the debate. We have 64 code points, from 0 to 63. If we reserve one to say \"don't know\", that means using only 62 code points, the last one marking the unbounded range.",
              "createdAt": "2025-03-26T05:51:58Z",
              "updatedAt": "2025-03-26T05:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86h4pOz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T05:58:46Z",
          "updatedAt": "2025-03-26T05:58:47Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I really need to get going on writing the congestion control part. There are a couple of ways to use a \"bandwidth cap\". It could solve one specific problem, stop the \"slow start\" exponential growth early. It could fit with the \"careful resume\" mechanism -- very that the new connection has the same cap as the previous one before reusing values learned before. It could inform of bandwidth drop, controlling the building of queues when the congestion controller discovers the new capacity. It could inform \"resume after congestion\" mechanisms, to grow sending rate quicker after transient congestion stops. At the application level, it can inform choice of codecs...",
              "createdAt": "2025-03-26T05:58:46Z",
              "updatedAt": "2025-03-26T05:58:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iP_c_",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T15:07:14Z",
          "updatedAt": "2025-03-27T15:07:14Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Filed #17 ",
              "createdAt": "2025-03-27T15:07:14Z",
              "updatedAt": "2025-03-27T15:07:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iQGWk",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T15:13:34Z",
          "updatedAt": "2025-03-27T15:13:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Filed #18 for followup though I'm largely in agreement with @martinthomson on this.",
              "createdAt": "2025-03-27T15:13:34Z",
              "updatedAt": "2025-03-27T15:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86iSFuB",
          "commit": {
            "abbreviatedOid": "1b73bf9"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-27T16:50:24Z",
          "updatedAt": "2025-03-27T16:50:24Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Filed #19 ",
              "createdAt": "2025-03-27T16:50:24Z",
              "updatedAt": "2025-03-27T16:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86jZV-N",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-03T22:21:54Z",
          "updatedAt": "2025-04-03T22:21:54Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "We can come back to that after merging this PR.",
              "createdAt": "2025-04-03T22:21:54Z",
              "updatedAt": "2025-04-03T22:21:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86jZWRw",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Let's merge this. We can iterate later.",
          "createdAt": "2025-04-03T22:22:55Z",
          "updatedAt": "2025-04-03T22:22:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86j3Gwz",
          "commit": {
            "abbreviatedOid": "ad1f597"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to merge, one small editorial nit that we can fix now or later.",
          "createdAt": "2025-04-08T08:29:54Z",
          "updatedAt": "2025-04-08T08:31:08Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "This reads a bit like a single TRONE packet can have two versions, perhaps rewrite as:\r\n``````suggestion\r\nA network element applies the same rate policy to TRONE packets of both \r\nversions, accounting for the different scales of each version. When a\r\n",
              "createdAt": "2025-04-08T08:29:54Z",
              "updatedAt": "2025-04-08T19:19:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86kCEii",
          "commit": {
            "abbreviatedOid": "5764ba5"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "+1 to merging.",
          "createdAt": "2025-04-09T04:34:16Z",
          "updatedAt": "2025-04-09T04:34:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDON1dwo86QF6Tw",
      "title": "Description of DOS attack against intermediaries",
      "url": "https://github.com/ietf-wg-scone/scone/pull/13",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adding a description of the attack listed in #11.\r\n\r\nClose #11",
      "createdAt": "2025-03-25T18:25:44Z",
      "updatedAt": "2025-04-30T20:12:48Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "sec-rec-inter",
      "headRefOid": "2ab4aaf3a97e170832d069c6898bc362d1141b43",
      "closedAt": "2025-04-30T20:12:48Z",
      "mergedAt": "2025-04-30T20:12:48Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "1489b93c4da78eb247271e6aa9116589adfdd96f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lC-nU",
          "commit": {
            "abbreviatedOid": "7433288"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is good, except for the terminology nits.\r\nI think we can expand on the guidance to network elements (e.g., requiring that you observe TRONE packets in both uplink and downlink directions of a 5-tuple makes the attacks somewhat more difficult to pull off), but that can be done later.",
          "createdAt": "2025-04-15T16:12:12Z",
          "updatedAt": "2025-04-15T16:17:59Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nis invalid or because decryption fail, but network elements cannot do these checks,\r\n```",
              "createdAt": "2025-04-15T16:12:13Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nand will have to process the packets. All the network elements between the injection\r\n```",
              "createdAt": "2025-04-15T16:12:51Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\na denial of service (DOS) attempt against network elements. The attack will\r\n```",
              "createdAt": "2025-04-15T16:13:35Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nforce the intermediaries to process the fake packets. If network elements\r\n```",
              "createdAt": "2025-04-15T16:13:56Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nthe rate of TRONE packets that a network element is willing to process;\r\n```",
              "createdAt": "2025-04-15T16:14:35Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\na processing error at network elements. For example, they might pick connection\r\nidentifiers of arbitrary length. Network elements can mitigate these attacks\r\n```",
              "createdAt": "2025-04-15T16:15:16Z",
              "updatedAt": "2025-04-15T16:18:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lSRzw",
          "commit": {
            "abbreviatedOid": "2ab4aaf"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for writing this!",
          "createdAt": "2025-04-16T15:52:45Z",
          "updatedAt": "2025-04-16T15:52:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lasB9",
          "commit": {
            "abbreviatedOid": "2ab4aaf"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T10:04:02Z",
          "updatedAt": "2025-04-17T10:04:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDON1dwo86QQjgP",
      "title": "First cut for congestion and TRONE interaction",
      "url": "https://github.com/ietf-wg-scone/scone/pull/16",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that we need to explicitly describe the interaction between congestion control and TRONE, if only to dispel any notion that TRONE replaces congestion control, as stated in issue #8. This is a first cut for describing such interactions. ",
      "createdAt": "2025-03-26T18:51:48Z",
      "updatedAt": "2025-04-30T10:02:35Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "681b12c446391332da002b4b3cf33a0d51ab3f64",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "first-congestion",
      "headRefOid": "37699bd37d10f56e306d78e055f3a13c884d3e6f",
      "closedAt": "2025-04-30T10:02:35Z",
      "mergedAt": "2025-04-30T10:02:35Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "649c6c08c4dd166071fd4bd23e33acf2d0ca67fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lJDps",
          "commit": {
            "abbreviatedOid": "05c4968"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T04:08:16Z",
          "updatedAt": "2025-04-16T04:08:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think text up to this paragraph if fine.\r\n\r\nBut for the remainder, I'm not sure if it'd be a good idea to imply TRONE as a signal that supplements congestion signals that indicate that more bandwidth might be available.\r\n\r\nI wonder if it would be better to explain the difference of the time scales congestion signals and TRONE signals act upon.\r\n\r\nThe time scale of congestion signals is in the unit of RTT, while I'd presume TRONE signals to indicate average b/w available across ~10 seconds; see https://github.com/ietf-wg-scone/trone/issues/20. For video playback using chunked files, the two signals would be handled differently; congestion control applies to the transport, while the TRONE signal would be used for choosing the chunks with the appropriate bitrate. Note each chunk can be sent much faster than the rate indicated by TRONE, as long as the average bitrate (including the idle period) remains below the TRONE value.",
              "createdAt": "2025-04-16T04:08:17Z",
              "updatedAt": "2025-04-16T04:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lTVJf",
          "commit": {
            "abbreviatedOid": "05c4968"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T17:28:03Z",
          "updatedAt": "2025-04-16T17:28:03Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Agreed. The following paragraphs are cut in the next commit.",
              "createdAt": "2025-04-16T17:28:03Z",
              "updatedAt": "2025-04-16T17:28:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lXf23",
          "commit": {
            "abbreviatedOid": "37699bd"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the updates! LG",
          "createdAt": "2025-04-17T03:08:54Z",
          "updatedAt": "2025-04-17T03:08:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86larO4",
          "commit": {
            "abbreviatedOid": "37699bd"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T10:02:40Z",
          "updatedAt": "2025-04-17T10:02:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDON1dwo86SskzI",
      "title": "Remove text on expanding datagrams.",
      "url": "https://github.com/ietf-wg-scone/scone/pull/22",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "How to handle network generated TRONE packets is a topic that requires WG discussion. \r\nI recommend that we remove any text on this topic for now and add something back based on the conclusion of #21.",
      "createdAt": "2025-04-15T16:05:26Z",
      "updatedAt": "2025-04-16T12:39:54Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "a4f79332ca9e716f7c255932d800191385ef33f4",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "ihlar-patch-1",
      "headRefOid": "8e0cd81a46e403c12e5e28b63109e6ebc3ec1f63",
      "closedAt": "2025-04-16T12:39:54Z",
      "mergedAt": "2025-04-16T12:39:54Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "d3cb3cd31bfcb6f51783734d7b552bec5de09663"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lDJtL",
          "commit": {
            "abbreviatedOid": "8e0cd81"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-15T16:26:20Z",
          "updatedAt": "2025-04-15T16:26:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lJGCc",
          "commit": {
            "abbreviatedOid": "8e0cd81"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-16T04:11:23Z",
          "updatedAt": "2025-04-16T04:11:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDON1dwo86SsueK",
      "title": "Add \"TRONE Indication\" strawman.",
      "url": "https://github.com/ietf-wg-scone/scone/pull/23",
      "state": "OPEN",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the meeting, and mentioned in #5, it is useful for an endpoint to signal its potential usage of TRONE to a network element. This initial pass uses a \"TRONE Indication\" packet which is probably excessive but is a fully reversed TRONE packet that's meant to go at the end of a datagram. This allows for the network element to first detect a QUIC initial, and then check the end of the packet for TRONE.\r\n\r\nAn alternative would be a more bespoke indicating like a concatenation of versions, or something like that.",
      "createdAt": "2025-04-15T16:23:30Z",
      "updatedAt": "2025-04-29T23:00:29Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "a4f79332ca9e716f7c255932d800191385ef33f4",
      "headRepository": "mjoras/trone",
      "headRefName": "main",
      "headRefOid": "2f3548f3523392f20915d3b492a258e288188cab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema @martinthomson thoughts on this?\r\n\r\nWe can merge as-is and remove fields later, or if we think it's important enough to cut them now I can change it to just be a QUIC version field.",
          "createdAt": "2025-04-16T16:34:53Z",
          "updatedAt": "2025-04-16T16:34:53Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we can merge this pull request (it'd be good to have all features being written down before the adoption call, but we can fix issues after adoption).\r\n\r\nHowever, I realize that indications cannot be designed based solely on Invariants, because packet coalescing is a version-specific concept defined in RFC 9000. So the text has to reflect that at some point at least, and the fact might have an affect on what we append.\r\n\r\nPS. Please see \u2193 for what I mean exactly.",
          "createdAt": "2025-04-18T00:45:20Z",
          "updatedAt": "2025-04-18T04:41:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I'm still unconvinced about the utility of this indication.  I know that we talked about it, but after thinking about it more, I don't think that it helps as much as you think it does.  Can we talk about this at the interim?",
          "createdAt": "2025-04-22T02:25:27Z",
          "updatedAt": "2025-04-22T02:25:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whatever we decide, we have to document what the concatenation of multiple Trone packets means, and whether it should be allowed. The draft assumes that a trone packet will be composed as:\r\n~~~\r\nTronePacket [*LongHeaderPacket] { LongHeaderPacket | ShortHeaderPacket }\r\n~~~\r\nThis PR proposes to assign a meaning to:\r\n~~~\r\nLongHeaderPacket *LongHeaderPacket TronePacket \r\n~~~\r\nI am not a great fan of that, and in particular not a great fan of encoding something at the tail of initial packets that must be padded to a fixed length. Implementation is a bit more complicated than it appears, and I am not really convince of the utility. But in any case, if we do that, we need to say something about potential combinations like:\r\n~~~\r\nTronePacket  InitialPacket TronePacket  \r\nInitialPacket TronePacket_Vx TronePacket_Vy\r\nInitialPacket TronePacket  0RTTPacket\r\nInitialPacket TronePacket  HandshakePacket\r\nTronePacket_Vx TronePacket_Vy ShortHeaderPacket \r\netc.\r\n~~~",
          "createdAt": "2025-04-22T05:32:01Z",
          "updatedAt": "2025-04-22T05:34:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "If this is just a regular SCONE(TM) packet, then I would expect that it doesn't matter which one is used or where it appears.  At least to the network element.  But safe negotiation of QUIC depends on this being *after* QUIC packets.  Otherwise, a QUIC implementation that doesn't implement SCONE will be forced to throw out the rest of the datagram.  That's no good.\r\n\r\nI'm more concerned that this doesn't help a network element much.  Even after this signal appears, the network element still doesn't know if the *server* is going to use the protocol.  So it still needs to put itself in a \"SCONE-pending state\", until it sees a SCONE(TM) packet.",
          "createdAt": "2025-04-22T06:05:01Z",
          "updatedAt": "2025-04-22T06:05:01Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema Based on my understanding that we want to build SCONE (TRONE) on top of QUIC Invariants, I do not think think we should be considering how coalescing affects TRONE.\r\n\r\nInvariants does not have the concept of coalesced packets.\r\n\r\nIf the version is TRONE, it is a TRONE packet. If it is not, then it is not.\r\n\r\nIf we are to have an indication, I think it has to be some junk being attached at the end of the datagram; please see https://github.com/mjoras/trone/pull/1. Regardless, it is not a coalesced packet.",
          "createdAt": "2025-04-22T06:22:58Z",
          "updatedAt": "2025-04-22T06:22:58Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I think that your [PR 1](https://github.com/mjoras/trone/pull/1) has the advantage of not muddying the concept of Trone packet, i.e., that they can only be found at the beginning of a datagram. We should say so.",
          "createdAt": "2025-04-22T06:33:03Z",
          "updatedAt": "2025-04-22T06:33:03Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quoting MT from https://github.com/mjoras/trone/pull/1#discussion_r2053501602:\r\n> (Indication at the end of the datagram) only works if all packets are understood enough to ignore them AND know their length. We have an existence proof of that not working in QUIC v1 (the short header packets) and there is no guarantee that other QUIC versions will retain a usable length.\r\n\r\nI agree that this is the concern.\r\n\r\nIf some feel strongly about having the indication, we could look for an alternative design.\r\n\r\nOne way forward would be to prepend TRONE Indication packets before QUIC v1 Initials (or any other version of QUIC that works end-to-end), and use SvcParamKey to advertise support of TRONE. If we take this path, the only case in which we would see an additional delay would be when the client does not have out-of-band knowledge and the name resolution uses A/AAAA records. How much do we need to care about such deployments?",
          "createdAt": "2025-04-22T08:25:30Z",
          "updatedAt": "2025-04-22T08:25:30Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Quoting MT from [mjoras#1 (comment)](https://github.com/mjoras/trone/pull/1#discussion_r2053501602):\r\n> \r\n> > (Indication at the end of the datagram) only works if all packets are understood enough to ignore them AND know their length. We have an existence proof of that not working in QUIC v1 (the short header packets) and there is no guarantee that other QUIC versions will retain a usable length.\r\n> \r\n> I agree that this is the concern.\r\n\r\nHow much of a concern is this? \r\nSending a TRONE indication packet is optional, a sender will know whether it is possible or not to append an indication. \r\n \r\n> If some feel strongly about having the indication, we could look for an alternative design.\r\n> \r\n> One way forward would be to prepend TRONE Indication packets before QUIC v1 Initials (or any other version of QUIC that works end-to-end), and use SvcParamKey to advertise support of TRONE. If we take this path, the only case in which we would see an additional delay would be when the client does not have out-of-band knowledge and the name resolution uses A/AAAA records. How much do we need to care about such deployments?\r\n\r\nThis would be a cleaner solution though.  \r\n\r\n",
          "createdAt": "2025-04-22T14:54:51Z",
          "updatedAt": "2025-04-22T14:54:51Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm more concerned that this doesn't help a network element much. Even after this signal appears, the network element still doesn't know if the _server_ is going to use the protocol. So it still needs to put itself in a \"SCONE-pending state\", until it sees a SCONE(TM) packet.\r\n\r\nYou're right, this is all the network element knows until it sees a downlink SCONE packet.\r\nHowever, current networks perform heavy DPI to determine whether flows are candidates for rate\u2011limiting policies. Early SCONE indications allow operators to omit that step.\r\nEven in a \u201cSCONE\u2011pending state,\u201d a network element can initiate rate monitoring and potentially revert to throttling at some point, regardless of whether SCONE packets are observed in the downlink.",
          "createdAt": "2025-04-22T15:12:32Z",
          "updatedAt": "2025-04-22T15:12:32Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ihlar \r\n> How much of a concern is this?\r\n> Sending a TRONE indication packet is optional, a sender will know whether it is possible or not to append an indication.\r\n\r\nI think the concern is that protocols other than QUIC v1 might not support TRONE, or that TRONE would become a constraint to the protocol designers, as it requires having a packet format that allows ignoring junk at the end. The strawman has issues even with QUIC v1 itself, QUIC v1 does not allow indications to be appended to packets sent on new paths after the handshake (as they would be short header packets).",
          "createdAt": "2025-04-22T23:33:27Z",
          "updatedAt": "2025-04-23T00:15:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": ">  Even in a \u201cSCONE\u2011pending state,\u201d a network element can initiate rate monitoring and potentially revert to throttling at some point, regardless of whether SCONE packets are observed in the downlink.\r\n\r\nThis seems to be key.  If you think that this state is distinct from a \"SCONE-pending\" state where you don't get an indicator, why would you not do that for all QUIC flows once you hit a certain adoption threshold?",
          "createdAt": "2025-04-23T01:49:49Z",
          "updatedAt": "2025-04-23T01:49:49Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the concern is that protocols other than QUIC v1 might not support TRONE, or that TRONE would become a constraint to the protocol designers, as it requires having a packet format that allows ignoring junk at the end. \r\n\r\nMakes sense, thanks.\r\n\r\n> The strawman has issues even with QUIC v1 itself, QUIC v1 does not allow indications to be appended to packets sent on new paths after the handshake (as they would be short header packets).\r\n\r\noth we should be able to send \"real\" SCONE packets at that point though?\r\n",
          "createdAt": "2025-04-28T14:48:04Z",
          "updatedAt": "2025-04-28T14:48:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> The strawman has issues even with QUIC v1 itself, QUIC v1 does not allow indications to be appended to packets sent on new paths after the handshake (as they would be short header packets).\r\n> \r\n> oth we should be able to send \"real\" SCONE packets at that point though?\r\n\r\nNot really, because SCONE packets and Indication are sent in different directions. The Indication as defined by this PR has only one form: appended at the end of the datagram, which is incompatible with short header packets of QUIC v1.\r\n\r\nBut separately, I think @martinthomson is raising an interesting question.\r\n\r\nNo matter how we design indications, they will not work when the client migrates involuntarily. Therefore, we will have to consider how we handle SCONE-compatible flows that do not send indications.\r\n\r\nConsidering that, I think it's worth discussing if network elements could handle all flows as potentially being SCONE-compatible, rather than relying on indications that might or might not work.",
          "createdAt": "2025-04-29T22:55:59Z",
          "updatedAt": "2025-04-29T23:00:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lFchD",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-15T20:05:41Z",
          "updatedAt": "2025-04-15T20:05:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86lJINs",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR.",
          "createdAt": "2025-04-16T04:15:03Z",
          "updatedAt": "2025-04-16T04:28:03Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthe QUIC handshake by attaching a TRONE indication packet after the last QUIC long header\r\npacket in the first UDP datagram. The TRONE indication provides an\r\n```\r\n\r\nTrone is designed to be QUIC-version-neutral, so it is better to avoid referring to concepts specific to QUIC v1. Also, even in v1, the first datagram that an endpoint sends might contain an Initial and a Handshake (consider servers).",
              "createdAt": "2025-04-16T04:15:03Z",
              "updatedAt": "2025-04-16T04:28:03Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nTRONE support by observing a full TRONE packet after the handshake completes.\r\n\r\nWhen sending QUIC short header packets in the first flight, endpoints SHOULD send them\r\nseparately from the first datagram carrying the TRONE indication packet, to avoid\r\nreceivers incapable of decoding TRONE packets from dropping the short header packet.\r\n```",
              "createdAt": "2025-04-16T04:21:56Z",
              "updatedAt": "2025-04-16T04:28:03Z"
            },
            {
              "originalPosition": 27,
              "body": "I think there is a question around what TRONE indication packets signal.\r\n\r\nIIRC, TRONE is unidirectional.\r\n\r\nAssuming the use of a TRONE indication packet signals that the sender is capable of _receiving_ TRONE packets, I do not think we need the Rate Signal field here (and separately, I think we can use a different version number for indication packets).",
              "createdAt": "2025-04-16T04:27:46Z",
              "updatedAt": "2025-04-16T14:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lR86Z",
          "commit": {
            "abbreviatedOid": "7647de5"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T15:24:25Z",
          "updatedAt": "2025-04-16T15:24:25Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Agreed, I think all the fields here are likely excessive, but kept them in for now so we can discuss further. A new version is probably fine in terms of avoiding false positives.",
              "createdAt": "2025-04-16T15:24:25Z",
              "updatedAt": "2025-04-16T15:24:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDON1dwo86S8gIt",
      "title": "allow network elements rewrite the version field",
      "url": "https://github.com/ietf-wg-scone/scone/pull/25",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in https://github.com/ietf-wg-scone/trone/issues/14#issuecomment-2809099526 and during yesterday's interim, we can simplify the design by allowing network elements rewrite the version field.\r\n\r\nNow, senders need to send only one packet (0xTRONE2 with rate=0x3f) instead of sending one for each of the two versions, and receivers no longer need to calculate the minimum of two values.\r\n\r\nMaybe closes #14 and #19.",
      "createdAt": "2025-04-17T07:09:13Z",
      "updatedAt": "2025-04-30T08:17:08Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "d3cb3cd31bfcb6f51783734d7b552bec5de09663",
      "headRepository": "kazuho/i-d-trone",
      "headRefName": "kazuho/changing-versions",
      "headRefOid": "6cd6dac6489a78922f2b3b2b653c47a2b8bc014c",
      "closedAt": "2025-04-30T08:17:08Z",
      "mergedAt": "2025-04-30T08:17:08Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "ee3f5886f37fedc26d0ff01dd926dc2e26ec6e51"
      },
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this! Was writing up something basically the same.\r\n\r\nDo we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.",
          "createdAt": "2025-04-18T00:26:09Z",
          "updatedAt": "2025-04-18T00:26:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for checking!\r\n\r\n> Do we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.\r\n\r\nMaybe raise as a different issue?\r\n\r\nBut FWIW, I do not think we want to neither allow or prohibit endpoints from mangling other versions of QUIC. It is not our business, and in the future, we might see another version of QUIC that recommends endpoints doing such a thing (example: a super-ECN signal that changes the bits in UDP payload). I think what we might need to add is a pointer to RFC 8999 regarding the topic.",
          "createdAt": "2025-04-18T01:57:46Z",
          "updatedAt": "2025-04-18T01:57:46Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Do we think we need any language stipulating that network elements should explicitly ignore any version that is not 0xTRONE1/2? It is sort of implied by QUIC long header semantics, but it might be worth noting explicitly that an element shouldn't stomp on a potential protocol it doesn't understand.\r\n> \r\n> Maybe raise as a different issue?\r\n\r\nAgree to handling this in a separate issue. The way the design is described is good enough for a document to get adopted. We can decide on additional guidance later on. \r\n",
          "createdAt": "2025-04-22T09:34:10Z",
          "updatedAt": "2025-04-22T09:34:10Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should merge this prior to an adoption call. Any concerns with that?",
          "createdAt": "2025-04-29T07:53:15Z",
          "updatedAt": "2025-04-29T07:53:15Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merge it!",
          "createdAt": "2025-04-29T21:12:33Z",
          "updatedAt": "2025-04-29T21:12:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86lakq6",
          "commit": {
            "abbreviatedOid": "d40d68e"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for this PR. \r\nLooks really good, small nit commented below. ",
          "createdAt": "2025-04-17T09:52:01Z",
          "updatedAt": "2025-04-17T09:58:59Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "178 is at n = 61 \r\nn = 62 should be ~199.53. \r\n\r\n```suggestion\r\nWith two versions combined, bitrates between 100 Kbps and 199.5 Gbps can be\r\n```",
              "createdAt": "2025-04-17T09:52:01Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n| 0xTRONE2 | 62          | 199.5 Gbps  |\r\n```",
              "createdAt": "2025-04-17T09:53:17Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n   (up to 199.5 Gbps)\r\n```",
              "createdAt": "2025-04-17T09:53:57Z",
              "updatedAt": "2025-04-17T09:58:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86lbbuP",
          "commit": {
            "abbreviatedOid": "d40d68e"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-17T11:34:12Z",
          "updatedAt": "2025-04-17T11:34:12Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Thank you!",
              "createdAt": "2025-04-17T11:34:12Z",
              "updatedAt": "2025-04-17T11:34:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86m3hiF",
          "commit": {
            "abbreviatedOid": "6cd6dac"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T14:44:55Z",
          "updatedAt": "2025-04-28T14:44:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDON1dwo86ULi6t",
      "title": "trone -> scone",
      "url": "https://github.com/ietf-wg-scone/scone/pull/28",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As agreed at interim and confirmed with authors, let's use SCONE as the protocol name. ",
      "createdAt": "2025-04-28T14:43:02Z",
      "updatedAt": "2025-05-05T14:46:37Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "f6cf9f1ad983298eea9027d8a5bc2f4d49dbe68b",
      "headRepository": "ietf-wg-scone/scone",
      "headRefName": "trone-to-scone",
      "headRefOid": "0cb881f4da13308f620972813e20e4dad81644c0",
      "closedAt": "2025-05-05T14:46:37Z",
      "mergedAt": "2025-05-05T14:46:36Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "3f18ab7745e0e0b158f298a3cd507a178d28d0db"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 @martinthomson. It would be natural to make that PR post adoption as a WG item, move from `draft-thoji-scone-trone-protocol-nn` to `draft-ietf-scone-protocol-00`, and have the new draft replace the old one.",
          "createdAt": "2025-04-29T07:25:18Z",
          "updatedAt": "2025-04-29T07:25:18Z"
        },
        {
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To move repo, we have two options:\r\n1. rename repo\r\n2. create a new repo and delete old \"trone\" repo\r\nI would suggest to take option 1, since option 1 leaves freedom to change draft name by yourselves. If we take option 2, all PRs and open issues might be lost. \r\nMake sense?",
          "createdAt": "2025-04-30T08:09:46Z",
          "updatedAt": "2025-04-30T08:09:46Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> To move repo, we have two options:\r\n> \r\n> 1. rename repo\r\n> 2. create a new repo and delete old \"trone\" repo\r\n>    I would suggest to take option 1, since option 1 leaves freedom to change draft name by yourselves. If we take option 2, all PRs and open issues might be lost.\r\n>    Make sense?\r\n\r\nAgree, option 1 sounds best.",
          "createdAt": "2025-04-30T09:35:14Z",
          "updatedAt": "2025-04-30T09:35:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Marcus.  Also, when you rename a repo, all the current links to this name will redirect for a decent amount of time; there's no risk that someone will hit a broken link.",
          "createdAt": "2025-04-30T10:32:54Z",
          "updatedAt": "2025-04-30T10:32:54Z"
        },
        {
          "author": "billwuqin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, I have renamed repo as 'scone' repo. Hope everything works well.",
          "createdAt": "2025-04-30T10:36:52Z",
          "updatedAt": "2025-04-30T10:36:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given where things stand, I'm OK with merging this now.  @huitema suggested that our (prospective) WG-00 not include any text changes, but I don't think we need to worry about a simple s/trone/scone/i for that; we have to rename other things when submitting a -00 anyway.",
          "createdAt": "2025-04-30T10:42:55Z",
          "updatedAt": "2025-04-30T10:42:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86m_yfG",
          "commit": {
            "abbreviatedOid": "8e97da6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Should we ask the chairs to move the repo first, then we can ensure that the links don't need to update twice.",
          "createdAt": "2025-04-29T03:02:48Z",
          "updatedAt": "2025-04-29T03:02:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDON1dwo86Ul5t7",
      "title": "When detecting flows not adhering to SCONE signals, RECOMMEND acting as if SCONE was not used",
      "url": "https://github.com/ietf-wg-scone/scone/pull/30",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request expands what SCONE being advisory means to network elements (i.e., that they should handle non-adhering SCONE flows as if it was not a SCONE flow).\r\n\r\nCloses #29.",
      "createdAt": "2025-05-01T01:18:50Z",
      "updatedAt": "2025-05-05T14:40:11Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "1489b93c4da78eb247271e6aa9116589adfdd96f",
      "headRepository": "kazuho/i-d-trone",
      "headRefName": "kazuho/endpoints-that-do-not-adhere",
      "headRefOid": "387b0287d682c480e19af2ee65782dd0e3245293",
      "closedAt": "2025-05-05T14:40:11Z",
      "mergedAt": "2025-05-05T14:40:10Z",
      "mergedBy": "ihlar",
      "mergeCommit": {
        "oid": "f6cf9f1ad983298eea9027d8a5bc2f4d49dbe68b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86nbS7v",
          "commit": {
            "abbreviatedOid": "96d2b30"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Some suggestions, but thanks for doing the work here.",
          "createdAt": "2025-05-01T01:24:16Z",
          "updatedAt": "2025-05-01T01:27:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nthat it will adhere to them; in some cases, the endpoint cannot. For\r\nexample, a flow may initially be used to serve video chunks, with the client\r\n```",
              "createdAt": "2025-05-01T01:24:16Z",
              "updatedAt": "2025-05-01T01:27:38Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nbulk download for which bitrate adaptation is not applicable. Composite flows\r\nfrom multiple applications, such as tunneled flows, might only have a subset of\r\nthe involved applications that are capable of handling SCONE signals. Therefore,\r\nwhen a network element detects a\r\n```",
              "createdAt": "2025-05-01T01:25:40Z",
              "updatedAt": "2025-05-01T01:27:38Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nflow using more bandwidth than advertised via SCONE, congestion control\r\nsignals might be necessary to ensure that the flow does not exceed the\r\nlimits that are set in policy.\r\n```",
              "createdAt": "2025-05-01T01:27:28Z",
              "updatedAt": "2025-05-01T01:27:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86nbWwY",
          "commit": {
            "abbreviatedOid": "96d2b30"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T01:36:01Z",
          "updatedAt": "2025-05-01T01:36:01Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thank you for the review. Other changes made total sense, but I'm not fully certain about this one.\r\n\r\nWhile it is true that CC might be necessary to force flows to be in policy, the proposed change does not address the original issue; i.e., that network elements should not punish non-adhering flows more so than non-SCONE flows. If network elements start behaving as such, endpoint developers would have no choice but to disable SCONE.\r\n\r\nWhat about something like: \"congestion control signals can be used to ensure that the flow performs on par with non-SCONE flows.\"?",
              "createdAt": "2025-05-01T01:36:01Z",
              "updatedAt": "2025-05-01T01:36:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86nbwu7",
          "commit": {
            "abbreviatedOid": "96d2b30"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T03:03:19Z",
          "updatedAt": "2025-05-01T03:03:20Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@martinthomson Went ahead with 387b028, please let me know what you think.",
              "createdAt": "2025-05-01T03:03:20Z",
              "updatedAt": "2025-05-01T03:03:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86nb2hK",
          "commit": {
            "abbreviatedOid": "387b028"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "That's better than what I suggested, thanks @kazuho.",
          "createdAt": "2025-05-01T03:44:54Z",
          "updatedAt": "2025-05-01T03:44:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86ncE6G",
          "commit": {
            "abbreviatedOid": "387b028"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "No objection. ",
          "createdAt": "2025-05-01T04:40:50Z",
          "updatedAt": "2025-05-01T04:40:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDON1dwo86nuhZ3",
          "commit": {
            "abbreviatedOid": "387b028"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks.",
          "createdAt": "2025-05-05T07:22:52Z",
          "updatedAt": "2025-05-05T07:22:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDON1dwo86V3kpP",
      "title": "Add usage of SCONE for throughput advice outside of rate-limiting",
      "url": "https://github.com/ietf-wg-scone/scone/pull/31",
      "state": "OPEN",
      "author": "Kevsy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This PR explicitly includes in scope networks that do not rate limit, but wish to advise on network conditions to help achieve the optimal sender rate. \r\n\r\nNotes on changes:\r\nThroughout: replaced 'rate limit signal' with 'throughput advice signal' to account for both uses of SCONE (to signal rate limits/to signal throughput advice based on current network conditions)\r\n\r\nLine 68: Changed 'Many access networks limit the maximum data rate that attached devices are able to attain'  (because all shared access networks do this due to finite bandwidth) to 'Many access networks apply rate limits to constrain the data rate of attached devices.' (to more explicitly indicate active rate limiting).\r\n\r\nLine 164: Removed \"In that case, capacity is less likely to be split between multiple active flows.\" because capacity will always be divided between multiple active flows (otherwise they would not be active)\r\n\r\nLine 165: Added that a SCONE signal based on the network's calculation of throughput advice would take into account congestion, whereas (as stated in the original) one simply stating a rate limit would not.\r\n\r\n(Other suggested changes are editorial)",
      "createdAt": "2025-05-12T16:37:48Z",
      "updatedAt": "2025-05-19T15:24:37Z",
      "baseRepository": "ietf-wg-scone/scone",
      "baseRefName": "main",
      "baseRefOid": "0e00e6531e8e68bcd034e22c6edeede4c999acc3",
      "headRepository": "Kevsy/scone",
      "headRefName": "patch-1",
      "headRefOid": "e9f071c9060bb55572369f810a75c0357e46cfab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "body": "Thanks @kazuho : https://github.com/ietf-wg-scone/scone/pull/31#discussion_r2090372600 explains it so I have put the text back for now, but I'll suggest a rewording in another PR to avoid bloating this PR.",
          "createdAt": "2025-05-15T08:37:48Z",
          "updatedAt": "2025-05-15T08:37:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDON1dwo86o_lXd",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The global search and replace didn't account for capitalization properly.  The substance of other changes is also against some of the established agreements around the divide between this work and congestion control.",
          "createdAt": "2025-05-13T04:33:23Z",
          "updatedAt": "2025-05-13T04:41:48Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nThis document describes a protocol where on-path network elements\r\ncan give endpoints their perspective on what the maximum achievable\r\nthroughput might be for QUIC flows.\r\n```\r\n\r\nThis can be shorter, and I think we don't need to get into what might cause a network element to offer this advice, rather we just need to establish that network elements have a perspective and that that perspective might be useful to communicate.",
              "createdAt": "2025-05-13T04:33:24Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n```\r\n\r\nSee above.",
              "createdAt": "2025-05-13T04:33:36Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 35,
              "body": "I would instead say this:\r\n\r\n```suggestion\r\nNetwork elements are not limited to communicating information\r\nabout rate limiting policies.\r\nNetwork elements in access networks could provide information\r\nto endpoints that can help account for changes in network capacity\r\nthat are not suited to congestion control feedback. This might include\r\nreduced capacity due to overuse, equipment faults, or other transient issues; \r\nconversely, networks might choose to signal increased availability of capacity.\r\n```",
              "createdAt": "2025-05-13T04:38:12Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 62,
              "body": "I think we need a better word than \"suggest\" for CC signals.",
              "createdAt": "2025-05-13T04:38:28Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 88,
              "body": "I don't like this one.  The idea that this mechanism is good for congestion feedback is not something that has broad support.  That's why ECN or similar mechanisms are for.",
              "createdAt": "2025-05-13T04:39:46Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 124,
              "body": "The tentative position thus far is that we will be specifying a time period, even if we do not define a scope.  I'd rather not touch this text just now if it is changing.",
              "createdAt": "2025-05-13T04:40:30Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\n## Applying Throughput Advice Signals {#apply}\r\n```",
              "createdAt": "2025-05-13T04:40:41Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThroughput advice signals are not a substitute for congestion feedback.  Congestion\r\n```",
              "createdAt": "2025-05-13T04:40:54Z",
              "updatedAt": "2025-05-13T04:41:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pAAOC",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This PR is premature. We should have a discussion in the issue first, and when we do have consensus on the issue process a PR.\r\n\r\nThe issue discusses replacing \"rate limit\" by \"throughput advice\". We have first to agree that this is a good idea. I think it might be, but with a caveat:\r\n\r\n1. It should be completely OK for networks that do not perform any explicit rate limit to still provide an advice, such as \"this network is engineered to support at most 100Mbps per flow\".\r\n\r\n2. It is definitely not OK to expect the throughput advice to reflect instant conditions, such as \"the path from New York to LA is currently congested\". This is the role of congestion signals, which operate on a much shorter time scale.",
          "createdAt": "2025-05-13T05:54:51Z",
          "updatedAt": "2025-05-13T06:06:16Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I think that \"indicate\" is correct. The probability of setting ECN/CE marks is function of the length of queues observed in the node. ECN/EC marks set that way do indeed indeed \"indicate\" the state of the network.",
              "createdAt": "2025-05-13T05:54:51Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 88,
              "body": "+1\r\nThe feedback loop between network state and throughput advice can be very loose. ECN and other congestion signals react in 1 RTT; SCONE feedback takes much longer, relies on endpoint polling the network. Let's not mix these two.",
              "createdAt": "2025-05-13T05:57:43Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 94,
              "body": "This is a true statement. What's the rationale for removing it?",
              "createdAt": "2025-05-13T05:58:14Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 124,
              "body": "+1. This PR should be limited to replacing \"rate limit\" by \"Throughput advice\".",
              "createdAt": "2025-05-13T05:59:13Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            },
            {
              "originalPosition": 191,
              "body": "typo, combination",
              "createdAt": "2025-05-13T05:59:52Z",
              "updatedAt": "2025-05-13T06:06:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pCqnw",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T09:52:51Z",
          "updatedAt": "2025-05-13T09:52:52Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "> This is a true statement. What's the rationale for removing it?\r\n\r\nQuite probably my misunderstanding - but my rationale is that  capacity will always be split between multiple active flows in a best effort access network. I'm also not clear why downlink is specified but not uplink..?",
              "createdAt": "2025-05-13T09:52:51Z",
              "updatedAt": "2025-05-13T09:52:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDFE2",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:23:28Z",
          "updatedAt": "2025-05-13T10:23:28Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Thanks, that suggestion covers the motive for the PR in one paragraph :)",
              "createdAt": "2025-05-13T10:23:28Z",
              "updatedAt": "2025-05-13T10:23:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDFq9",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:24:25Z",
          "updatedAt": "2025-05-13T10:24:26Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nmarkings {{?ECN=RFC3168}} that indicate the real-time condition of a network\r\n```",
              "createdAt": "2025-05-13T10:24:25Z",
              "updatedAt": "2025-05-13T10:24:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDF-d",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:24:55Z",
          "updatedAt": "2025-05-13T10:24:56Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nmarkings {{?ECN=RFC3168}} that indicate the real-time condition of a network\r\n```",
              "createdAt": "2025-05-13T10:24:55Z",
              "updatedAt": "2025-05-13T10:24:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDGP5",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:25:22Z",
          "updatedAt": "2025-05-13T10:25:22Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Reverted to 'indicate'",
              "createdAt": "2025-05-13T10:25:22Z",
              "updatedAt": "2025-05-13T10:25:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDIcn",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:28:33Z",
          "updatedAt": "2025-05-13T10:28:33Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\npath.  Congestion signals might indicate a throughput that is different from the\r\n```",
              "createdAt": "2025-05-13T10:28:33Z",
              "updatedAt": "2025-05-13T10:28:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDJdK",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:30:11Z",
          "updatedAt": "2025-05-13T10:30:11Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Reverted to 'indicate'",
              "createdAt": "2025-05-13T10:30:11Z",
              "updatedAt": "2025-05-13T10:30:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDMcH",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:34:49Z",
          "updatedAt": "2025-05-13T10:34:50Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nexpected throughput.  That throughput will only be achievable when there is no\r\nsignificant data flowing in the same scope.  In the presence of other flows,\r\ncongestion limits are likely to determine actual throughput.\r\n```",
              "createdAt": "2025-05-13T10:34:49Z",
              "updatedAt": "2025-05-13T10:34:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDOEU",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:36:39Z",
          "updatedAt": "2025-05-13T10:36:40Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Reverted (except I have kept 'throughput' in place of the original 'rate limit')",
              "createdAt": "2025-05-13T10:36:39Z",
              "updatedAt": "2025-05-13T10:36:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pDQ89",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-13T10:39:56Z",
          "updatedAt": "2025-05-13T10:39:56Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "> +1. This PR should be limited to replacing \"rate limit\" by \"Throughput advice\".\r\n\r\nI think it can also include Martin's text that says rate limiting is not the only use (line 83-86 in the PR), and together those would cover my motive for raising the PR",
              "createdAt": "2025-05-13T10:39:56Z",
              "updatedAt": "2025-05-13T10:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pMFVM",
          "commit": {
            "abbreviatedOid": "787e594"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "With the changes, this is fine.  It's not going to be an endorsement of using the signal for real-time adaptation, like network congestion, so I'm OK with the switch to \"throughput advice\".",
          "createdAt": "2025-05-14T02:01:38Z",
          "updatedAt": "2025-05-14T02:04:39Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "```suggestion\r\nin a position to drop datagrams and could apply a rate limit policy.\r\n```",
              "createdAt": "2025-05-14T02:01:38Z",
              "updatedAt": "2025-05-14T02:04:39Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\nnetwork conditions, or a combination of the two.\r\n```",
              "createdAt": "2025-05-14T02:01:57Z",
              "updatedAt": "2025-05-14T02:04:39Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n## Providing Opportunities to Apply Throughput Advice Signals {#extra-packets}\r\n```",
              "createdAt": "2025-05-14T02:02:09Z",
              "updatedAt": "2025-05-14T02:04:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pNzfg",
          "commit": {
            "abbreviatedOid": "6fed991"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-14T06:56:46Z",
          "updatedAt": "2025-05-14T06:56:46Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I'm OK with this generally now.  However, this no longer makes sense as a statement:\r\n\r\n> The effective throughput advice might change without being signaled.\r\n\r\nShould we drop that line?  Or is there a different statement for this?  I'm leaning toward cutting it.",
              "createdAt": "2025-05-14T06:56:46Z",
              "updatedAt": "2025-05-14T06:56:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pa6dL",
          "commit": {
            "abbreviatedOid": "6fed991"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the efforts. Have minor comments but looks good overall.",
          "createdAt": "2025-05-15T06:23:10Z",
          "updatedAt": "2025-05-15T06:26:55Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "Isn't it still the case that when the advice changes while the endpoints is in quiescence, the endpoints would end up sending data without being signaled?",
              "createdAt": "2025-05-15T06:23:10Z",
              "updatedAt": "2025-05-15T06:26:55Z"
            },
            {
              "originalPosition": 94,
              "body": "I think the statement is suggesting that at the very last mile, it is likely that there is only one active connection at a time. I think that is true and relevant here.",
              "createdAt": "2025-05-15T06:26:21Z",
              "updatedAt": "2025-05-15T06:26:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcUWJ",
          "commit": {
            "abbreviatedOid": "6fed991"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:31:04Z",
          "updatedAt": "2025-05-15T08:31:05Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nThis makes the application of signals most usefully applied to a downlink flow\r\nin access networks, close to an endpoint. In that case, capacity is less likely\r\nto be split between multiple active flows.\r\n```",
              "createdAt": "2025-05-15T08:31:05Z",
              "updatedAt": "2025-05-15T08:31:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcbBt",
          "commit": {
            "abbreviatedOid": "e9f071c"
          },
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:40:27Z",
          "updatedAt": "2025-05-15T08:40:28Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "The typical case that causes swearing at throughput is the adult watching TV and the teenager turning on his video game; the adult complains that the news is showing a spinner mid-stream; the teenager complains that his controller is sluggish. Multiple flows at the last mile are normal, expected, and should be engineered for.",
              "createdAt": "2025-05-15T08:40:27Z",
              "updatedAt": "2025-05-15T08:40:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcbin",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:41:06Z",
          "updatedAt": "2025-05-15T08:41:06Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Reverted, but I will raise another PR with suggested rewording",
              "createdAt": "2025-05-15T08:41:06Z",
              "updatedAt": "2025-05-15T08:41:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86pcf0O",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "Kevsy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T08:46:37Z",
          "updatedAt": "2025-05-15T08:46:37Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "would removing 'advice' here cover it, i.e.  'The effective throughput might change without being signaled'?",
              "createdAt": "2025-05-15T08:46:37Z",
              "updatedAt": "2025-05-15T08:46:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86peeC_",
          "commit": {
            "abbreviatedOid": "90ec4ed"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-15T11:27:46Z",
          "updatedAt": "2025-05-15T11:27:46Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "@alvestrand, that's what a congestion controller ultimately has to be used for.  The design here doesn't address that case, except to the extent that the sluggish game might fit between the rate limit cap and the capacity that the video uses.\r\n\r\nLooking forward to what @Kevsy suggests here.",
              "createdAt": "2025-05-15T11:27:46Z",
              "updatedAt": "2025-05-15T11:27:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDON1dwo86p8aMY",
          "commit": {
            "abbreviatedOid": "e9f071c"
          },
          "author": "ihlar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T15:24:37Z",
          "updatedAt": "2025-05-19T15:24:37Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "> would removing 'advice' here cover it, i.e. 'The effective throughput might change without being signaled'?\r\n\r\nTo me that misses the quiescence point that @kazuho makes, since \"effective throughput\" sounds like something active that you measure.\r\n\r\nPerhaps rephrasing it to something like:\r\n\r\n\u201cNetwork conditions and rate-limit policies can change in ways that make previously signaled advice obsolete, and there are no guarantees that updated advice will be sent.\u201d\r\n\r\n\r\n\r\n",
              "createdAt": "2025-05-19T15:24:37Z",
              "updatedAt": "2025-05-19T15:24:55Z"
            }
          ]
        }
      ]
    }
  ]
}